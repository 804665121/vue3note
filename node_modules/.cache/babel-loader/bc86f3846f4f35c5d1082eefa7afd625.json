{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/*!\n  * pinia v2.0.13\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, onUnmounted, reactive, toRef, del, nextTick, computed, toRefs } from 'vue-demi';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n/**\r\n * setActivePinia must be called to handle SSR at the top of functions like\r\n * `fetch`, `setup`, `serverPrefetch` and others\r\n */\n\nlet activePinia;\n/**\r\n * Sets or unsets the active pinia. Used in SSR and internally when calling\r\n * actions and getters\r\n *\r\n * @param pinia - Pinia instance\r\n */\n\nconst setActivePinia = pinia => activePinia = pinia;\n/**\r\n * Get the currently active pinia if there is any.\r\n */\n\n\nconst getActivePinia = () => getCurrentInstance() && inject(piniaSymbol) || activePinia;\n\nconst piniaSymbol = process.env.NODE_ENV !== 'production' ? Symbol('pinia') :\n/* istanbul ignore next */\nSymbol();\n\nfunction isPlainObject( // eslint-disable-next-line @typescript-eslint/no-explicit-any\no) {\n  return o && typeof o === 'object' && Object.prototype.toString.call(o) === '[object Object]' && typeof o.toJSON !== 'function';\n} // type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\n// TODO: can we change these to numbers?\n\n/**\r\n * Possible types for SubscriptionCallback\r\n */\n\n\nvar MutationType;\n\n(function (MutationType) {\n  /**\r\n   * Direct mutation of the state:\r\n   *\r\n   * - `store.name = 'new name'`\r\n   * - `store.$state.name = 'new name'`\r\n   * - `store.list.push('new item')`\r\n   */\n  MutationType[\"direct\"] = \"direct\";\n  /**\r\n   * Mutated the state with `$patch` and an object\r\n   *\r\n   * - `store.$patch({ name: 'newName' })`\r\n   */\n\n  MutationType[\"patchObject\"] = \"patch object\";\n  /**\r\n   * Mutated the state with `$patch` and a function\r\n   *\r\n   * - `store.$patch(state => state.name = 'newName')`\r\n   */\n\n  MutationType[\"patchFunction\"] = \"patch function\"; // maybe reset? for $state = {} and $reset\n})(MutationType || (MutationType = {}));\n\nconst IS_CLIENT = typeof window !== 'undefined';\n/*\r\n * FileSaver.js A saveAs() FileSaver implementation.\r\n *\r\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\r\n * Morote.\r\n *\r\n * License : MIT\r\n */\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\n\nconst _global = /*#__PURE__*/(() => typeof window === 'object' && window.window === window ? window : typeof self === 'object' && self.self === self ? self : typeof global === 'object' && global.global === global ? global : typeof globalThis === 'object' ? globalThis : {\n  HTMLElement: null\n})();\n\nfunction bom(blob, {\n  autoBom = false\n} = {}) {\n  // prepend BOM for UTF-8 XML and text/* types (including HTML)\n  // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n  if (autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n    return new Blob([String.fromCharCode(0xfeff), blob], {\n      type: blob.type\n    });\n  }\n\n  return blob;\n}\n\nfunction download(url, name, opts) {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', url);\n  xhr.responseType = 'blob';\n\n  xhr.onload = function () {\n    saveAs(xhr.response, name, opts);\n  };\n\n  xhr.onerror = function () {\n    console.error('could not download file');\n  };\n\n  xhr.send();\n}\n\nfunction corsEnabled(url) {\n  const xhr = new XMLHttpRequest(); // use sync to avoid popup blocker\n\n  xhr.open('HEAD', url, false);\n\n  try {\n    xhr.send();\n  } catch (e) {}\n\n  return xhr.status >= 200 && xhr.status <= 299;\n} // `a.click()` doesn't work for all browsers (#465)\n\n\nfunction click(node) {\n  try {\n    node.dispatchEvent(new MouseEvent('click'));\n  } catch (e) {\n    const evt = document.createEvent('MouseEvents');\n    evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\n    node.dispatchEvent(evt);\n  }\n}\n\nconst _navigator = typeof navigator === 'object' ? navigator : {\n  userAgent: ''\n}; // Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\n\n\nconst isMacOSWebView = /*#__PURE__*/(() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();\n\nconst saveAs = !IS_CLIENT ? () => {} // noop\n: // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\ntypeof HTMLAnchorElement !== 'undefined' && 'download' in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : // Use msSaveOrOpenBlob as a second approach\n'msSaveOrOpenBlob' in _navigator ? msSaveAs : // Fallback to using FileReader and a popup\nfileSaverSaveAs;\n\nfunction downloadSaveAs(blob, name = 'download', opts) {\n  const a = document.createElement('a');\n  a.download = name;\n  a.rel = 'noopener'; // tabnabbing\n  // TODO: detect chrome extensions & packaged apps\n  // a.target = '_blank'\n\n  if (typeof blob === 'string') {\n    // Support regular links\n    a.href = blob;\n\n    if (a.origin !== location.origin) {\n      if (corsEnabled(a.href)) {\n        download(blob, name, opts);\n      } else {\n        a.target = '_blank';\n        click(a);\n      }\n    } else {\n      click(a);\n    }\n  } else {\n    // Support blobs\n    a.href = URL.createObjectURL(blob);\n    setTimeout(function () {\n      URL.revokeObjectURL(a.href);\n    }, 4e4); // 40s\n\n    setTimeout(function () {\n      click(a);\n    }, 0);\n  }\n}\n\nfunction msSaveAs(blob, name = 'download', opts) {\n  if (typeof blob === 'string') {\n    if (corsEnabled(blob)) {\n      download(blob, name, opts);\n    } else {\n      const a = document.createElement('a');\n      a.href = blob;\n      a.target = '_blank';\n      setTimeout(function () {\n        click(a);\n      });\n    }\n  } else {\n    // @ts-ignore: works on windows\n    navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n  }\n}\n\nfunction fileSaverSaveAs(blob, name, opts, popup) {\n  // Open a popup immediately do go around popup blocker\n  // Mostly only available on user interaction and the fileReader is async so...\n  popup = popup || open('', '_blank');\n\n  if (popup) {\n    popup.document.title = popup.document.body.innerText = 'downloading...';\n  }\n\n  if (typeof blob === 'string') return download(blob, name, opts);\n  const force = blob.type === 'application/octet-stream';\n\n  const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\n\n  const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n\n  if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== 'undefined') {\n    // Safari doesn't allow downloading of blob URLs\n    const reader = new FileReader();\n\n    reader.onloadend = function () {\n      let url = reader.result;\n\n      if (typeof url !== 'string') {\n        popup = null;\n        throw new Error('Wrong reader.result type');\n      }\n\n      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\n      if (popup) {\n        popup.location.href = url;\n      } else {\n        location.assign(url);\n      }\n\n      popup = null; // reverse-tabnabbing #460\n    };\n\n    reader.readAsDataURL(blob);\n  } else {\n    const url = URL.createObjectURL(blob);\n    if (popup) popup.location.assign(url);else location.href = url;\n    popup = null; // reverse-tabnabbing #460\n\n    setTimeout(function () {\n      URL.revokeObjectURL(url);\n    }, 4e4); // 40s\n  }\n}\n/**\r\n * Shows a toast or console.log\r\n *\r\n * @param message - message to log\r\n * @param type - different color of the tooltip\r\n */\n\n\nfunction toastMessage(message, type) {\n  const piniaMessage = 'ðŸ ' + message;\n\n  if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\n    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\n  } else if (type === 'error') {\n    console.error(piniaMessage);\n  } else if (type === 'warn') {\n    console.warn(piniaMessage);\n  } else {\n    console.log(piniaMessage);\n  }\n}\n\nfunction isPinia(o) {\n  return '_a' in o && 'install' in o;\n}\n\nfunction checkClipboardAccess() {\n  if (!('clipboard' in navigator)) {\n    toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\n    return true;\n  }\n}\n\nfunction checkNotFocusedError(error) {\n  if (error instanceof Error && error.message.toLowerCase().includes('document is not focused')) {\n    toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\n    return true;\n  }\n\n  return false;\n}\n\nasync function actionGlobalCopyState(pinia) {\n  if (checkClipboardAccess()) return;\n\n  try {\n    await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\n    toastMessage('Global state copied to clipboard.');\n  } catch (error) {\n    if (checkNotFocusedError(error)) return;\n    toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\n    console.error(error);\n  }\n}\n\nasync function actionGlobalPasteState(pinia) {\n  if (checkClipboardAccess()) return;\n\n  try {\n    pinia.state.value = JSON.parse(await navigator.clipboard.readText());\n    toastMessage('Global state pasted from clipboard.');\n  } catch (error) {\n    if (checkNotFocusedError(error)) return;\n    toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\n    console.error(error);\n  }\n}\n\nasync function actionGlobalSaveState(pinia) {\n  try {\n    saveAs(new Blob([JSON.stringify(pinia.state.value)], {\n      type: 'text/plain;charset=utf-8'\n    }), 'pinia-state.json');\n  } catch (error) {\n    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\n    console.error(error);\n  }\n}\n\nlet fileInput;\n\nfunction getFileOpener() {\n  if (!fileInput) {\n    fileInput = document.createElement('input');\n    fileInput.type = 'file';\n    fileInput.accept = '.json';\n  }\n\n  function openFile() {\n    return new Promise((resolve, reject) => {\n      fileInput.onchange = async () => {\n        const files = fileInput.files;\n        if (!files) return resolve(null);\n        const file = files.item(0);\n        if (!file) return resolve(null);\n        return resolve({\n          text: await file.text(),\n          file\n        });\n      }; // @ts-ignore: TODO: changed from 4.3 to 4.4\n\n\n      fileInput.oncancel = () => resolve(null);\n\n      fileInput.onerror = reject;\n      fileInput.click();\n    });\n  }\n\n  return openFile;\n}\n\nasync function actionGlobalOpenStateFile(pinia) {\n  try {\n    const open = await getFileOpener();\n    const result = await open();\n    if (!result) return;\n    const {\n      text,\n      file\n    } = result;\n    pinia.state.value = JSON.parse(text);\n    toastMessage(`Global state imported from \"${file.name}\".`);\n  } catch (error) {\n    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\n    console.error(error);\n  }\n}\n\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n}\n\nconst PINIA_ROOT_LABEL = 'ðŸ Pinia (root)';\nconst PINIA_ROOT_ID = '_root';\n\nfunction formatStoreForInspectorTree(store) {\n  return isPinia(store) ? {\n    id: PINIA_ROOT_ID,\n    label: PINIA_ROOT_LABEL\n  } : {\n    id: store.$id,\n    label: store.$id\n  };\n}\n\nfunction formatStoreForInspectorState(store) {\n  if (isPinia(store)) {\n    const storeNames = Array.from(store._s.keys());\n    const storeMap = store._s;\n    const state = {\n      state: storeNames.map(storeId => ({\n        editable: true,\n        key: storeId,\n        value: store.state.value[storeId]\n      })),\n      getters: storeNames.filter(id => storeMap.get(id)._getters).map(id => {\n        const store = storeMap.get(id);\n        return {\n          editable: false,\n          key: id,\n          value: store._getters.reduce((getters, key) => {\n            getters[key] = store[key];\n            return getters;\n          }, {})\n        };\n      })\n    };\n    return state;\n  }\n\n  const state = {\n    state: Object.keys(store.$state).map(key => ({\n      editable: true,\n      key,\n      value: store.$state[key]\n    }))\n  }; // avoid adding empty getters\n\n  if (store._getters && store._getters.length) {\n    state.getters = store._getters.map(getterName => ({\n      editable: false,\n      key: getterName,\n      value: store[getterName]\n    }));\n  }\n\n  if (store._customProperties.size) {\n    state.customProperties = Array.from(store._customProperties).map(key => ({\n      editable: true,\n      key,\n      value: store[key]\n    }));\n  }\n\n  return state;\n}\n\nfunction formatEventData(events) {\n  if (!events) return {};\n\n  if (Array.isArray(events)) {\n    // TODO: handle add and delete for arrays and objects\n    return events.reduce((data, event) => {\n      data.keys.push(event.key);\n      data.operations.push(event.type);\n      data.oldValue[event.key] = event.oldValue;\n      data.newValue[event.key] = event.newValue;\n      return data;\n    }, {\n      oldValue: {},\n      keys: [],\n      operations: [],\n      newValue: {}\n    });\n  } else {\n    return {\n      operation: formatDisplay(events.type),\n      key: formatDisplay(events.key),\n      oldValue: events.oldValue,\n      newValue: events.newValue\n    };\n  }\n}\n\nfunction formatMutationType(type) {\n  switch (type) {\n    case MutationType.direct:\n      return 'mutation';\n\n    case MutationType.patchFunction:\n      return '$patch';\n\n    case MutationType.patchObject:\n      return '$patch';\n\n    default:\n      return 'unknown';\n  }\n} // timeline can be paused when directly changing the state\n\n\nlet isTimelineActive = true;\nconst componentStateTypes = [];\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\nconst INSPECTOR_ID = 'pinia';\n/**\r\n * Gets the displayed name of a store in devtools\r\n *\r\n * @param id - id of the store\r\n * @returns a formatted string\r\n */\n\nconst getStoreType = id => 'ðŸ ' + id;\n/**\r\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\r\n * as soon as it is added to the application.\r\n *\r\n * @param app - Vue application\r\n * @param pinia - pinia instance\r\n */\n\n\nfunction registerPiniaDevtools(app, pinia) {\n  setupDevtoolsPlugin({\n    id: 'dev.esm.pinia',\n    label: 'Pinia ðŸ',\n    logo: 'https://pinia.vuejs.org/logo.svg',\n    packageName: 'pinia',\n    homepage: 'https://pinia.vuejs.org',\n    componentStateTypes,\n    app\n  }, api => {\n    if (typeof api.now !== 'function') {\n      toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\n    }\n\n    api.addTimelineLayer({\n      id: MUTATIONS_LAYER_ID,\n      label: `Pinia ðŸ`,\n      color: 0xe5df88\n    });\n    api.addInspector({\n      id: INSPECTOR_ID,\n      label: 'Pinia ðŸ',\n      icon: 'storage',\n      treeFilterPlaceholder: 'Search stores',\n      actions: [{\n        icon: 'content_copy',\n        action: () => {\n          actionGlobalCopyState(pinia);\n        },\n        tooltip: 'Serialize and copy the state'\n      }, {\n        icon: 'content_paste',\n        action: async () => {\n          await actionGlobalPasteState(pinia);\n          api.sendInspectorTree(INSPECTOR_ID);\n          api.sendInspectorState(INSPECTOR_ID);\n        },\n        tooltip: 'Replace the state with the content of your clipboard'\n      }, {\n        icon: 'save',\n        action: () => {\n          actionGlobalSaveState(pinia);\n        },\n        tooltip: 'Save the state as a JSON file'\n      }, {\n        icon: 'folder_open',\n        action: async () => {\n          await actionGlobalOpenStateFile(pinia);\n          api.sendInspectorTree(INSPECTOR_ID);\n          api.sendInspectorState(INSPECTOR_ID);\n        },\n        tooltip: 'Import the state from a JSON file'\n      }]\n    });\n    api.on.inspectComponent((payload, ctx) => {\n      const proxy = payload.componentInstance && payload.componentInstance.proxy;\n\n      if (proxy && proxy._pStores) {\n        const piniaStores = payload.componentInstance.proxy._pStores;\n        Object.values(piniaStores).forEach(store => {\n          payload.instanceData.state.push({\n            type: getStoreType(store.$id),\n            key: 'state',\n            editable: true,\n            value: store._isOptionsAPI ? {\n              _custom: {\n                value: store.$state,\n                actions: [{\n                  icon: 'restore',\n                  tooltip: 'Reset the state of this store',\n                  action: () => store.$reset()\n                }]\n              }\n            } : store.$state\n          });\n\n          if (store._getters && store._getters.length) {\n            payload.instanceData.state.push({\n              type: getStoreType(store.$id),\n              key: 'getters',\n              editable: false,\n              value: store._getters.reduce((getters, key) => {\n                try {\n                  getters[key] = store[key];\n                } catch (error) {\n                  // @ts-expect-error: we just want to show it in devtools\n                  getters[key] = error;\n                }\n\n                return getters;\n              }, {})\n            });\n          }\n        });\n      }\n    });\n    api.on.getInspectorTree(payload => {\n      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n        let stores = [pinia];\n        stores = stores.concat(Array.from(pinia._s.values()));\n        payload.rootNodes = (payload.filter ? stores.filter(store => '$id' in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);\n      }\n    });\n    api.on.getInspectorState(payload => {\n      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);\n\n        if (!inspectedStore) {\n          // this could be the selected store restored for a different project\n          // so it's better not to say anything here\n          return;\n        }\n\n        if (inspectedStore) {\n          payload.state = formatStoreForInspectorState(inspectedStore);\n        }\n      }\n    });\n    api.on.editInspectorState((payload, ctx) => {\n      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);\n\n        if (!inspectedStore) {\n          return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\n        }\n\n        const {\n          path\n        } = payload;\n\n        if (!isPinia(inspectedStore)) {\n          // access only the state\n          if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {\n            path.unshift('$state');\n          }\n        } else {\n          // Root access, we can omit the `.value` because the devtools API does it for us\n          path.unshift('state');\n        }\n\n        isTimelineActive = false;\n        payload.set(inspectedStore, path, payload.state.value);\n        isTimelineActive = true;\n      }\n    });\n    api.on.editComponentState(payload => {\n      if (payload.type.startsWith('ðŸ')) {\n        const storeId = payload.type.replace(/^ðŸ\\s*/, '');\n\n        const store = pinia._s.get(storeId);\n\n        if (!store) {\n          return toastMessage(`store \"${storeId}\" not found`, 'error');\n        }\n\n        const {\n          path\n        } = payload;\n\n        if (path[0] !== 'state') {\n          return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\n        } // rewrite the first entry to be able to directly set the state as\n        // well as any other path\n\n\n        path[0] = '$state';\n        isTimelineActive = false;\n        payload.set(store, path, payload.state.value);\n        isTimelineActive = true;\n      }\n    });\n  });\n}\n\nfunction addStoreToDevtools(app, store) {\n  if (!componentStateTypes.includes(getStoreType(store.$id))) {\n    componentStateTypes.push(getStoreType(store.$id));\n  }\n\n  setupDevtoolsPlugin({\n    id: 'dev.esm.pinia',\n    label: 'Pinia ðŸ',\n    logo: 'https://pinia.vuejs.org/logo.svg',\n    packageName: 'pinia',\n    homepage: 'https://pinia.vuejs.org',\n    componentStateTypes,\n    app,\n    settings: {\n      logStoreChanges: {\n        label: 'Notify about new/deleted stores',\n        type: 'boolean',\n        defaultValue: true\n      } // useEmojis: {\n      //   label: 'Use emojis in messages âš¡ï¸',\n      //   type: 'boolean',\n      //   defaultValue: true,\n      // },\n\n    }\n  }, api => {\n    // gracefully handle errors\n    const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\n    store.$onAction(({\n      after,\n      onError,\n      name,\n      args\n    }) => {\n      const groupId = runningActionId++;\n      api.addTimelineEvent({\n        layerId: MUTATIONS_LAYER_ID,\n        event: {\n          time: now(),\n          title: 'ðŸ›« ' + name,\n          subtitle: 'start',\n          data: {\n            store: formatDisplay(store.$id),\n            action: formatDisplay(name),\n            args\n          },\n          groupId\n        }\n      });\n      after(result => {\n        activeAction = undefined;\n        api.addTimelineEvent({\n          layerId: MUTATIONS_LAYER_ID,\n          event: {\n            time: now(),\n            title: 'ðŸ›¬ ' + name,\n            subtitle: 'end',\n            data: {\n              store: formatDisplay(store.$id),\n              action: formatDisplay(name),\n              args,\n              result\n            },\n            groupId\n          }\n        });\n      });\n      onError(error => {\n        activeAction = undefined;\n        api.addTimelineEvent({\n          layerId: MUTATIONS_LAYER_ID,\n          event: {\n            time: now(),\n            logType: 'error',\n            title: 'ðŸ’¥ ' + name,\n            subtitle: 'end',\n            data: {\n              store: formatDisplay(store.$id),\n              action: formatDisplay(name),\n              args,\n              error\n            },\n            groupId\n          }\n        });\n      });\n    }, true);\n\n    store._customProperties.forEach(name => {\n      watch(() => unref(store[name]), (newValue, oldValue) => {\n        api.notifyComponentUpdate();\n        api.sendInspectorState(INSPECTOR_ID);\n\n        if (isTimelineActive) {\n          api.addTimelineEvent({\n            layerId: MUTATIONS_LAYER_ID,\n            event: {\n              time: now(),\n              title: 'Change',\n              subtitle: name,\n              data: {\n                newValue,\n                oldValue\n              },\n              groupId: activeAction\n            }\n          });\n        }\n      }, {\n        deep: true\n      });\n    });\n\n    store.$subscribe(({\n      events,\n      type\n    }, state) => {\n      api.notifyComponentUpdate();\n      api.sendInspectorState(INSPECTOR_ID);\n      if (!isTimelineActive) return; // rootStore.state[store.id] = state\n\n      const eventData = {\n        time: now(),\n        title: formatMutationType(type),\n        data: {\n          store: formatDisplay(store.$id),\n          ...formatEventData(events)\n        },\n        groupId: activeAction\n      }; // reset for the next mutation\n\n      activeAction = undefined;\n\n      if (type === MutationType.patchFunction) {\n        eventData.subtitle = 'â¤µï¸';\n      } else if (type === MutationType.patchObject) {\n        eventData.subtitle = 'ðŸ§©';\n      } else if (events && !Array.isArray(events)) {\n        eventData.subtitle = events.type;\n      }\n\n      if (events) {\n        eventData.data['rawEvent(s)'] = {\n          _custom: {\n            display: 'DebuggerEvent',\n            type: 'object',\n            tooltip: 'raw DebuggerEvent[]',\n            value: events\n          }\n        };\n      }\n\n      api.addTimelineEvent({\n        layerId: MUTATIONS_LAYER_ID,\n        event: eventData\n      });\n    }, {\n      detached: true,\n      flush: 'sync'\n    });\n    const hotUpdate = store._hotUpdate;\n    store._hotUpdate = markRaw(newStore => {\n      hotUpdate(newStore);\n      api.addTimelineEvent({\n        layerId: MUTATIONS_LAYER_ID,\n        event: {\n          time: now(),\n          title: 'ðŸ”¥ ' + store.$id,\n          subtitle: 'HMR update',\n          data: {\n            store: formatDisplay(store.$id),\n            info: formatDisplay(`HMR update`)\n          }\n        }\n      }); // update the devtools too\n\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(INSPECTOR_ID);\n      api.sendInspectorState(INSPECTOR_ID);\n    });\n    const {\n      $dispose\n    } = store;\n\n    store.$dispose = () => {\n      $dispose();\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(INSPECTOR_ID);\n      api.sendInspectorState(INSPECTOR_ID);\n      api.getSettings().logStoreChanges && toastMessage(`Disposed \"${store.$id}\" store ðŸ—‘`);\n    }; // trigger an update so it can display new registered stores\n\n\n    api.notifyComponentUpdate();\n    api.sendInspectorTree(INSPECTOR_ID);\n    api.sendInspectorState(INSPECTOR_ID);\n    api.getSettings().logStoreChanges && toastMessage(`\"${store.$id}\" store installed ðŸ†•`);\n  });\n}\n\nlet runningActionId = 0;\nlet activeAction;\n/**\r\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\r\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\r\n * mutation to the action.\r\n *\r\n * @param store - store to patch\r\n * @param actionNames - list of actionst to patch\r\n */\n\nfunction patchActionForGrouping(store, actionNames) {\n  // original actions of the store as they are given by pinia. We are going to override them\n  const actions = actionNames.reduce((storeActions, actionName) => {\n    // use toRaw to avoid tracking #541\n    storeActions[actionName] = toRaw(store)[actionName];\n    return storeActions;\n  }, {});\n\n  for (const actionName in actions) {\n    store[actionName] = function () {\n      // setActivePinia(store._p)\n      // the running action id is incremented in a before action hook\n      const _actionId = runningActionId;\n      const trackedStore = new Proxy(store, {\n        get(...args) {\n          activeAction = _actionId;\n          return Reflect.get(...args);\n        },\n\n        set(...args) {\n          activeAction = _actionId;\n          return Reflect.set(...args);\n        }\n\n      });\n      return actions[actionName].apply(trackedStore, arguments);\n    };\n  }\n}\n/**\r\n * pinia.use(devtoolsPlugin)\r\n */\n\n\nfunction devtoolsPlugin({\n  app,\n  store,\n  options\n}) {\n  // HMR module\n  if (store.$id.startsWith('__hot:')) {\n    return;\n  } // detect option api vs setup api\n\n\n  if (options.state) {\n    store._isOptionsAPI = true;\n  } // only wrap actions in option-defined stores as this technique relies on\n  // wrapping the context of the action with a proxy\n\n\n  if (typeof options.state === 'function') {\n    patchActionForGrouping( // @ts-expect-error: can cast the store...\n    store, Object.keys(options.actions));\n    const originalHotUpdate = store._hotUpdate; // Upgrade the HMR to also update the new actions\n\n    toRaw(store)._hotUpdate = function (newStore) {\n      originalHotUpdate.apply(this, arguments);\n      patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions));\n    };\n  }\n\n  addStoreToDevtools(app, // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\n  store);\n}\n/**\r\n * Creates a Pinia instance to be used by the application\r\n */\n\n\nfunction createPinia() {\n  const scope = effectScope(true); // NOTE: here we could check the window object for a state and directly set it\n  // if there is anything like it with Vue 3 SSR\n\n  const state = scope.run(() => ref({}));\n  let _p = []; // plugins added before calling app.use(pinia)\n\n  let toBeInstalled = [];\n  const pinia = markRaw({\n    install(app) {\n      // this allows calling useStore() outside of a component setup after\n      // installing pinia's plugin\n      setActivePinia(pinia);\n\n      if (!isVue2) {\n        pinia._a = app;\n        app.provide(piniaSymbol, pinia);\n        app.config.globalProperties.$pinia = pinia;\n        /* istanbul ignore else */\n\n        if (process.env.NODE_ENV !== 'production' && IS_CLIENT) {\n          registerPiniaDevtools(app, pinia);\n        }\n\n        toBeInstalled.forEach(plugin => _p.push(plugin));\n        toBeInstalled = [];\n      }\n    },\n\n    use(plugin) {\n      if (!this._a && !isVue2) {\n        toBeInstalled.push(plugin);\n      } else {\n        _p.push(plugin);\n      }\n\n      return this;\n    },\n\n    _p,\n    // it's actually undefined here\n    // @ts-expect-error\n    _a: null,\n    _e: scope,\n    _s: new Map(),\n    state\n  }); // pinia devtools rely on dev only features so they cannot be forced unless\n  // the dev build of Vue is used\n\n  if (process.env.NODE_ENV !== 'production' && IS_CLIENT) {\n    pinia.use(devtoolsPlugin);\n  }\n\n  return pinia;\n}\n/**\r\n * Checks if a function is a `StoreDefinition`.\r\n *\r\n * @param fn - object to test\r\n * @returns true if `fn` is a StoreDefinition\r\n */\n\n\nconst isUseStore = fn => {\n  return typeof fn === 'function' && typeof fn.$id === 'string';\n};\n/**\r\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\r\n * remove any key not existing in `newState` and recursively merge plain\r\n * objects.\r\n *\r\n * @param newState - new state object to be patched\r\n * @param oldState - old state that should be used to patch newState\r\n * @returns - newState\r\n */\n\n\nfunction patchObject(newState, oldState) {\n  // no need to go through symbols because they cannot be serialized anyway\n  for (const key in oldState) {\n    const subPatch = oldState[key]; // skip the whole sub tree\n\n    if (!(key in newState)) {\n      continue;\n    }\n\n    const targetValue = newState[key];\n\n    if (isPlainObject(targetValue) && isPlainObject(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {\n      newState[key] = patchObject(targetValue, subPatch);\n    } else {\n      // objects are either a bit more complex (e.g. refs) or primitives, so we\n      // just set the whole thing\n      if (isVue2) {\n        set(newState, key, subPatch);\n      } else {\n        newState[key] = subPatch;\n      }\n    }\n  }\n\n  return newState;\n}\n/**\r\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\r\n *\r\n * @example\r\n * ```js\r\n * const useUser = defineStore(...)\r\n * if (import.meta.hot) {\r\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\r\n * }\r\n * ```\r\n *\r\n * @param initialUseStore - return of the defineStore to hot update\r\n * @param hot - `import.meta.hot`\r\n */\n\n\nfunction acceptHMRUpdate(initialUseStore, hot) {\n  return newModule => {\n    const pinia = hot.data.pinia || initialUseStore._pinia;\n\n    if (!pinia) {\n      // this store is still not used\n      return;\n    } // preserve the pinia instance across loads\n\n\n    hot.data.pinia = pinia; // console.log('got data', newStore)\n\n    for (const exportName in newModule) {\n      const useStore = newModule[exportName]; // console.log('checking for', exportName)\n\n      if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\n        // console.log('Accepting update for', useStore.$id)\n        const id = useStore.$id;\n\n        if (id !== initialUseStore.$id) {\n          console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`); // return import.meta.hot.invalidate()\n\n          return hot.invalidate();\n        }\n\n        const existingStore = pinia._s.get(id);\n\n        if (!existingStore) {\n          console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\n          return;\n        }\n\n        useStore(pinia, existingStore);\n      }\n    }\n  };\n}\n\nconst noop = () => {};\n\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\n  subscriptions.push(callback);\n\n  const removeSubscription = () => {\n    const idx = subscriptions.indexOf(callback);\n\n    if (idx > -1) {\n      subscriptions.splice(idx, 1);\n      onCleanup();\n    }\n  };\n\n  if (!detached && getCurrentInstance()) {\n    onUnmounted(removeSubscription);\n  }\n\n  return removeSubscription;\n}\n\nfunction triggerSubscriptions(subscriptions, ...args) {\n  subscriptions.slice().forEach(callback => {\n    callback(...args);\n  });\n}\n\nfunction mergeReactiveObjects(target, patchToApply) {\n  // no need to go through symbols because they cannot be serialized anyway\n  for (const key in patchToApply) {\n    if (!patchToApply.hasOwnProperty(key)) continue;\n    const subPatch = patchToApply[key];\n    const targetValue = target[key];\n\n    if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {\n      target[key] = mergeReactiveObjects(targetValue, subPatch);\n    } else {\n      // @ts-expect-error: subPatch is a valid value\n      target[key] = subPatch;\n    }\n  }\n\n  return target;\n}\n\nconst skipHydrateSymbol = process.env.NODE_ENV !== 'production' ? Symbol('pinia:skipHydration') :\n/* istanbul ignore next */\nSymbol();\nconst skipHydrateMap = /*#__PURE__*/new WeakMap();\n\nfunction skipHydrate(obj) {\n  return isVue2 ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\n\n  /* istanbul ignore next */\n  skipHydrateMap.set(obj, 1) && obj : Object.defineProperty(obj, skipHydrateSymbol, {});\n}\n\nfunction shouldHydrate(obj) {\n  return isVue2 ?\n  /* istanbul ignore next */\n  !skipHydrateMap.has(obj) : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\n}\n\nconst {\n  assign\n} = Object;\n\nfunction isComputed(o) {\n  return !!(isRef(o) && o.effect);\n}\n\nfunction createOptionsStore(id, options, pinia, hot) {\n  const {\n    state,\n    actions,\n    getters\n  } = options;\n  const initialState = pinia.state.value[id];\n  let store;\n\n  function setup() {\n    if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n      /* istanbul ignore if */\n      if (isVue2) {\n        set(pinia.state.value, id, state ? state() : {});\n      } else {\n        pinia.state.value[id] = state ? state() : {};\n      }\n    } // avoid creating a state in pinia.state.value\n\n\n    const localState = process.env.NODE_ENV !== 'production' && hot ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\n    toRefs(ref(state ? state() : {}).value) : toRefs(pinia.state.value[id]);\n    return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\n      computedGetters[name] = markRaw(computed(() => {\n        setActivePinia(pinia); // it was created just before\n\n        const store = pinia._s.get(id); // allow cross using stores\n\n        /* istanbul ignore next */\n\n\n        if (isVue2 && !store._r) return; // @ts-expect-error\n        // return getters![name].call(context, context)\n        // TODO: avoid reading the getter while assigning with a global variable\n\n        return getters[name].call(store, store);\n      }));\n      return computedGetters;\n    }, {}));\n  }\n\n  store = createSetupStore(id, setup, options, pinia, hot);\n\n  store.$reset = function $reset() {\n    const newState = state ? state() : {}; // we use a patch to group all changes into one single subscription\n\n    this.$patch($state => {\n      assign($state, newState);\n    });\n  };\n\n  return store;\n}\n\nfunction createSetupStore($id, setup, options = {}, pinia, hot) {\n  let scope;\n  const buildState = options.state;\n  const optionsForPlugin = assign({\n    actions: {}\n  }, options);\n  /* istanbul ignore if */\n\n  if (process.env.NODE_ENV !== 'production' && !pinia._e.active) {\n    throw new Error('Pinia destroyed');\n  } // watcher options for $subscribe\n\n\n  const $subscribeOptions = {\n    deep: true // flush: 'post',\n\n  };\n  /* istanbul ignore else */\n\n  if (process.env.NODE_ENV !== 'production' && !isVue2) {\n    $subscribeOptions.onTrigger = event => {\n      /* istanbul ignore else */\n      if (isListening) {\n        debuggerEvents = event; // avoid triggering this while the store is being built and the state is being set in pinia\n      } else if (isListening == false && !store._hotUpdating) {\n        // let patch send all the events together later\n\n        /* istanbul ignore else */\n        if (Array.isArray(debuggerEvents)) {\n          debuggerEvents.push(event);\n        } else {\n          console.error('ðŸ debuggerEvents should be an array. This is most likely an internal Pinia bug.');\n        }\n      }\n    };\n  } // internal state\n\n\n  let isListening; // set to true at the end\n\n  let isSyncListening; // set to true at the end\n\n  let subscriptions = markRaw([]);\n  let actionSubscriptions = markRaw([]);\n  let debuggerEvents;\n  const initialState = pinia.state.value[$id]; // avoid setting the state for option stores are it is set\n  // by the setup\n\n  if (!buildState && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n    /* istanbul ignore if */\n    if (isVue2) {\n      set(pinia.state.value, $id, {});\n    } else {\n      pinia.state.value[$id] = {};\n    }\n  }\n\n  const hotState = ref({});\n\n  function $patch(partialStateOrMutator) {\n    let subscriptionMutation;\n    isListening = isSyncListening = false; // reset the debugger events since patches are sync\n\n    /* istanbul ignore else */\n\n    if (process.env.NODE_ENV !== 'production') {\n      debuggerEvents = [];\n    }\n\n    if (typeof partialStateOrMutator === 'function') {\n      partialStateOrMutator(pinia.state.value[$id]);\n      subscriptionMutation = {\n        type: MutationType.patchFunction,\n        storeId: $id,\n        events: debuggerEvents\n      };\n    } else {\n      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\n      subscriptionMutation = {\n        type: MutationType.patchObject,\n        payload: partialStateOrMutator,\n        storeId: $id,\n        events: debuggerEvents\n      };\n    }\n\n    nextTick().then(() => {\n      isListening = true;\n    });\n    isSyncListening = true; // because we paused the watcher, we need to manually call the subscriptions\n\n    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\n  }\n  /* istanbul ignore next */\n\n\n  const $reset = process.env.NODE_ENV !== 'production' ? () => {\n    throw new Error(`ðŸ: Store \"${$id}\" is build using the setup syntax and does not implement $reset().`);\n  } : noop;\n\n  function $dispose() {\n    scope.stop();\n    subscriptions = [];\n    actionSubscriptions = [];\n\n    pinia._s.delete($id);\n  }\n  /**\r\n   * Wraps an action to handle subscriptions.\r\n   *\r\n   * @param name - name of the action\r\n   * @param action - action to wrap\r\n   * @returns a wrapped action to handle subscriptions\r\n   */\n\n\n  function wrapAction(name, action) {\n    return function () {\n      setActivePinia(pinia);\n      const args = Array.from(arguments);\n      const afterCallbackList = [];\n      const onErrorCallbackList = [];\n\n      function after(callback) {\n        afterCallbackList.push(callback);\n      }\n\n      function onError(callback) {\n        onErrorCallbackList.push(callback);\n      } // @ts-expect-error\n\n\n      triggerSubscriptions(actionSubscriptions, {\n        args,\n        name,\n        store,\n        after,\n        onError\n      });\n      let ret;\n\n      try {\n        ret = action.apply(this && this.$id === $id ? this : store, args); // handle sync errors\n      } catch (error) {\n        triggerSubscriptions(onErrorCallbackList, error);\n        throw error;\n      }\n\n      if (ret instanceof Promise) {\n        return ret.then(value => {\n          triggerSubscriptions(afterCallbackList, value);\n          return value;\n        }).catch(error => {\n          triggerSubscriptions(onErrorCallbackList, error);\n          return Promise.reject(error);\n        });\n      } // allow the afterCallback to override the return value\n\n\n      triggerSubscriptions(afterCallbackList, ret);\n      return ret;\n    };\n  }\n\n  const _hmrPayload = /*#__PURE__*/markRaw({\n    actions: {},\n    getters: {},\n    state: [],\n    hotState\n  });\n\n  const partialStore = {\n    _p: pinia,\n    // _s: scope,\n    $id,\n    $onAction: addSubscription.bind(null, actionSubscriptions),\n    $patch,\n    $reset,\n\n    $subscribe(callback, options = {}) {\n      const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\n      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], state => {\n        if (options.flush === 'sync' ? isSyncListening : isListening) {\n          callback({\n            storeId: $id,\n            type: MutationType.direct,\n            events: debuggerEvents\n          }, state);\n        }\n      }, assign({}, $subscribeOptions, options)));\n      return removeSubscription;\n    },\n\n    $dispose\n  };\n  /* istanbul ignore if */\n\n  if (isVue2) {\n    // start as non ready\n    partialStore._r = false;\n  }\n\n  const store = reactive(assign(process.env.NODE_ENV !== 'production' && IS_CLIENT ? // devtools custom properties\n  {\n    _customProperties: markRaw(new Set()),\n    _hmrPayload\n  } : {}, partialStore // must be added later\n  // setupStore\n  )); // store the partial store now so the setup of stores can instantiate each other before they are finished without\n  // creating infinite loops.\n\n  pinia._s.set($id, store); // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\n\n\n  const setupStore = pinia._e.run(() => {\n    scope = effectScope();\n    return scope.run(() => setup());\n  }); // overwrite existing actions to support $onAction\n\n\n  for (const key in setupStore) {\n    const prop = setupStore[key];\n\n    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {\n      // mark it as a piece of state to be serialized\n      if (process.env.NODE_ENV !== 'production' && hot) {\n        set(hotState.value, key, toRef(setupStore, key)); // createOptionStore directly sets the state in pinia.state.value so we\n        // can just skip that\n      } else if (!buildState) {\n        // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\n        if (initialState && shouldHydrate(prop)) {\n          if (isRef(prop)) {\n            prop.value = initialState[key];\n          } else {\n            // probably a reactive object, lets recursively assign\n            mergeReactiveObjects(prop, initialState[key]);\n          }\n        } // transfer the ref to the pinia state to keep everything in sync\n\n        /* istanbul ignore if */\n\n\n        if (isVue2) {\n          set(pinia.state.value[$id], key, prop);\n        } else {\n          pinia.state.value[$id][key] = prop;\n        }\n      }\n      /* istanbul ignore else */\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        _hmrPayload.state.push(key);\n      } // action\n\n    } else if (typeof prop === 'function') {\n      // @ts-expect-error: we are overriding the function we avoid wrapping if\n      const actionValue = process.env.NODE_ENV !== 'production' && hot ? prop : wrapAction(key, prop); // this a hot module replacement store because the hotUpdate method needs\n      // to do it with the right context\n\n      /* istanbul ignore if */\n\n      if (isVue2) {\n        set(setupStore, key, actionValue);\n      } else {\n        // @ts-expect-error\n        setupStore[key] = actionValue;\n      }\n      /* istanbul ignore else */\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        _hmrPayload.actions[key] = prop;\n      } // list actions so they can be used in plugins\n      // @ts-expect-error\n\n\n      optionsForPlugin.actions[key] = prop;\n    } else if (process.env.NODE_ENV !== 'production') {\n      // add getters for devtools\n      if (isComputed(prop)) {\n        _hmrPayload.getters[key] = buildState ? // @ts-expect-error\n        options.getters[key] : prop;\n\n        if (IS_CLIENT) {\n          const getters = // @ts-expect-error: it should be on the store\n          setupStore._getters || (setupStore._getters = markRaw([]));\n          getters.push(key);\n        }\n      }\n    }\n  } // add the state, getters, and action properties\n\n  /* istanbul ignore if */\n\n\n  if (isVue2) {\n    Object.keys(setupStore).forEach(key => {\n      set(store, key, // @ts-expect-error: valid key indexing\n      setupStore[key]);\n    });\n  } else {\n    assign(store, setupStore); // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\n    // Make `storeToRefs()` work with `reactive()` #799\n\n    assign(toRaw(store), setupStore);\n  } // use this instead of a computed with setter to be able to create it anywhere\n  // without linking the computed lifespan to wherever the store is first\n  // created.\n\n\n  Object.defineProperty(store, '$state', {\n    get: () => process.env.NODE_ENV !== 'production' && hot ? hotState.value : pinia.state.value[$id],\n    set: state => {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && hot) {\n        throw new Error('cannot set hotState');\n      }\n\n      $patch($state => {\n        assign($state, state);\n      });\n    }\n  }); // add the hotUpdate before plugins to allow them to override it\n\n  /* istanbul ignore else */\n\n  if (process.env.NODE_ENV !== 'production') {\n    store._hotUpdate = markRaw(newStore => {\n      store._hotUpdating = true;\n\n      newStore._hmrPayload.state.forEach(stateKey => {\n        if (stateKey in store.$state) {\n          const newStateTarget = newStore.$state[stateKey];\n          const oldStateSource = store.$state[stateKey];\n\n          if (typeof newStateTarget === 'object' && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) {\n            patchObject(newStateTarget, oldStateSource);\n          } else {\n            // transfer the ref\n            newStore.$state[stateKey] = oldStateSource;\n          }\n        } // patch direct access properties to allow store.stateProperty to work as\n        // store.$state.stateProperty\n\n\n        set(store, stateKey, toRef(newStore.$state, stateKey));\n      }); // remove deleted state properties\n\n\n      Object.keys(store.$state).forEach(stateKey => {\n        if (!(stateKey in newStore.$state)) {\n          del(store, stateKey);\n        }\n      }); // avoid devtools logging this as a mutation\n\n      isListening = false;\n      isSyncListening = false;\n      pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\n      isSyncListening = true;\n      nextTick().then(() => {\n        isListening = true;\n      });\n\n      for (const actionName in newStore._hmrPayload.actions) {\n        const action = newStore[actionName];\n        set(store, actionName, wrapAction(actionName, action));\n      } // TODO: does this work in both setup and option store?\n\n\n      for (const getterName in newStore._hmrPayload.getters) {\n        const getter = newStore._hmrPayload.getters[getterName];\n        const getterValue = buildState ? // special handling of options api\n        computed(() => {\n          setActivePinia(pinia);\n          return getter.call(store, store);\n        }) : getter;\n        set(store, getterName, getterValue);\n      } // remove deleted getters\n\n\n      Object.keys(store._hmrPayload.getters).forEach(key => {\n        if (!(key in newStore._hmrPayload.getters)) {\n          del(store, key);\n        }\n      }); // remove old actions\n\n      Object.keys(store._hmrPayload.actions).forEach(key => {\n        if (!(key in newStore._hmrPayload.actions)) {\n          del(store, key);\n        }\n      }); // update the values used in devtools and to allow deleting new properties later on\n\n      store._hmrPayload = newStore._hmrPayload;\n      store._getters = newStore._getters;\n      store._hotUpdating = false;\n    });\n    const nonEnumerable = {\n      writable: true,\n      configurable: true,\n      // avoid warning on devtools trying to display this property\n      enumerable: false\n    };\n\n    if (IS_CLIENT) {\n      ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach(p => {\n        Object.defineProperty(store, p, {\n          value: store[p],\n          ...nonEnumerable\n        });\n      });\n    }\n  }\n  /* istanbul ignore if */\n\n\n  if (isVue2) {\n    // mark the store as ready before plugins\n    store._r = true;\n  } // apply all plugins\n\n\n  pinia._p.forEach(extender => {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production' && IS_CLIENT) {\n      const extensions = scope.run(() => extender({\n        store,\n        app: pinia._a,\n        pinia,\n        options: optionsForPlugin\n      }));\n      Object.keys(extensions || {}).forEach(key => store._customProperties.add(key));\n      assign(store, extensions);\n    } else {\n      assign(store, scope.run(() => extender({\n        store,\n        app: pinia._a,\n        pinia,\n        options: optionsForPlugin\n      })));\n    }\n  });\n\n  if (process.env.NODE_ENV !== 'production' && store.$state && typeof store.$state === 'object' && typeof store.$state.constructor === 'function' && !store.$state.constructor.toString().includes('[native code]')) {\n    console.warn(`[ðŸ]: The \"state\" must be a plain object. It cannot be\\n` + `\\tstate: () => new MyClass()\\n` + `Found in store \"${store.$id}\".`);\n  } // only apply hydrate to option stores with an initial state in pinia\n\n\n  if (initialState && buildState && options.hydrate) {\n    options.hydrate(store.$state, initialState);\n  }\n\n  isListening = true;\n  isSyncListening = true;\n  return store;\n}\n\nfunction defineStore( // TODO: add proper types from above\nidOrOptions, setup, setupOptions) {\n  let id;\n  let options;\n  const isSetupStore = typeof setup === 'function';\n\n  if (typeof idOrOptions === 'string') {\n    id = idOrOptions; // the option store setup will contain the actual options in this case\n\n    options = isSetupStore ? setupOptions : setup;\n  } else {\n    options = idOrOptions;\n    id = idOrOptions.id;\n  }\n\n  function useStore(pinia, hot) {\n    const currentInstance = getCurrentInstance();\n    pinia = // in test mode, ignore the argument provided as we can always retrieve a\n    // pinia instance with getActivePinia()\n    (process.env.NODE_ENV === 'test' && activePinia && activePinia._testing ? null : pinia) || currentInstance && inject(piniaSymbol);\n    if (pinia) setActivePinia(pinia);\n\n    if (process.env.NODE_ENV !== 'production' && !activePinia) {\n      throw new Error(`[ðŸ]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\\n` + `\\tconst pinia = createPinia()\\n` + `\\tapp.use(pinia)\\n` + `This will fail in production.`);\n    }\n\n    pinia = activePinia;\n\n    if (!pinia._s.has(id)) {\n      // creating the store registers it in `pinia._s`\n      if (isSetupStore) {\n        createSetupStore(id, setup, options, pinia);\n      } else {\n        createOptionsStore(id, options, pinia);\n      }\n      /* istanbul ignore else */\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        // @ts-expect-error: not the right inferred type\n        useStore._pinia = pinia;\n      }\n    }\n\n    const store = pinia._s.get(id);\n\n    if (process.env.NODE_ENV !== 'production' && hot) {\n      const hotId = '__hot:' + id;\n      const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign({}, options), pinia, true);\n\n      hot._hotUpdate(newStore); // cleanup the state properties and the store from the cache\n\n\n      delete pinia.state.value[hotId];\n\n      pinia._s.delete(hotId);\n    } // save stores in instances to access them devtools\n\n\n    if (process.env.NODE_ENV !== 'production' && IS_CLIENT && currentInstance && currentInstance.proxy && // avoid adding stores that are just built for hot module replacement\n    !hot) {\n      const vm = currentInstance.proxy;\n      const cache = '_pStores' in vm ? vm._pStores : vm._pStores = {};\n      cache[id] = store;\n    } // StoreGeneric cannot be casted towards Store\n\n\n    return store;\n  }\n\n  useStore.$id = id;\n  return useStore;\n}\n\nlet mapStoreSuffix = 'Store';\n/**\r\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\r\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\r\n * interface if you need are using TypeScript.\r\n *\r\n * @param suffix - new suffix\r\n */\n\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\n) {\n  mapStoreSuffix = suffix;\n}\n/**\r\n * Allows using stores without the composition API (`setup()`) by generating an\r\n * object to be spread in the `computed` field of a component. It accepts a list\r\n * of store definitions.\r\n *\r\n * @example\r\n * ```js\r\n * export default {\r\n *   computed: {\r\n *     // other computed properties\r\n *     ...mapStores(useUserStore, useCartStore)\r\n *   },\r\n *\r\n *   created() {\r\n *     this.userStore // store with id \"user\"\r\n *     this.cartStore // store with id \"cart\"\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @param stores - list of stores to map to an object\r\n */\n\n\nfunction mapStores(...stores) {\n  if (process.env.NODE_ENV !== 'production' && Array.isArray(stores[0])) {\n    console.warn(`[ðŸ]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` + `Replace\\n` + `\\tmapStores([useAuthStore, useCartStore])\\n` + `with\\n` + `\\tmapStores(useAuthStore, useCartStore)\\n` + `This will fail in production if not fixed.`);\n    stores = stores[0];\n  }\n\n  return stores.reduce((reduced, useStore) => {\n    // @ts-expect-error: $id is added by defineStore\n    reduced[useStore.$id + mapStoreSuffix] = function () {\n      return useStore(this.$pinia);\n    };\n\n    return reduced;\n  }, {});\n}\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\n\n\nfunction mapState(useStore, keysOrMapper) {\n  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {\n    reduced[key] = function () {\n      return useStore(this.$pinia)[key];\n    };\n\n    return reduced;\n  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {\n    // @ts-expect-error\n    reduced[key] = function () {\n      const store = useStore(this.$pinia);\n      const storeKey = keysOrMapper[key]; // for some reason TS is unable to infer the type of storeKey to be a\n      // function\n\n      return typeof storeKey === 'function' ? storeKey.call(this, store) : store[storeKey];\n    };\n\n    return reduced;\n  }, {});\n}\n/**\r\n * Alias for `mapState()`. You should use `mapState()` instead.\r\n * @deprecated use `mapState()` instead.\r\n */\n\n\nconst mapGetters = mapState;\n/**\r\n * Allows directly using actions from your store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `methods` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\n\nfunction mapActions(useStore, keysOrMapper) {\n  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {\n    // @ts-expect-error\n    reduced[key] = function (...args) {\n      return useStore(this.$pinia)[key](...args);\n    };\n\n    return reduced;\n  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {\n    // @ts-expect-error\n    reduced[key] = function (...args) {\n      return useStore(this.$pinia)[keysOrMapper[key]](...args);\n    };\n\n    return reduced;\n  }, {});\n}\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\n\n\nfunction mapWritableState(useStore, keysOrMapper) {\n  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {\n    // @ts-ignore\n    reduced[key] = {\n      get() {\n        return useStore(this.$pinia)[key];\n      },\n\n      set(value) {\n        // it's easier to type it here as any\n        return useStore(this.$pinia)[key] = value;\n      }\n\n    };\n    return reduced;\n  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {\n    // @ts-ignore\n    reduced[key] = {\n      get() {\n        return useStore(this.$pinia)[keysOrMapper[key]];\n      },\n\n      set(value) {\n        // it's easier to type it here as any\n        return useStore(this.$pinia)[keysOrMapper[key]] = value;\n      }\n\n    };\n    return reduced;\n  }, {});\n}\n/**\r\n * Creates an object of references with all the state, getters, and plugin-added\r\n * state properties of the store. Similar to `toRefs()` but specifically\r\n * designed for Pinia stores so methods and non reactive properties are\r\n * completely ignored.\r\n *\r\n * @param store - store to extract the refs from\r\n */\n\n\nfunction storeToRefs(store) {\n  // See https://github.com/vuejs/pinia/issues/852\n  // It's easier to just use toRefs() even if it includes more stuff\n  if (isVue2) {\n    // @ts-expect-error: toRefs include methods and others\n    return toRefs(store);\n  } else {\n    store = toRaw(store);\n    const refs = {};\n\n    for (const key in store) {\n      const value = store[key];\n\n      if (isRef(value) || isReactive(value)) {\n        // @ts-expect-error: the key is state or getter\n        refs[key] = // ---\n        toRef(store, key);\n      }\n    }\n\n    return refs;\n  }\n}\n/**\r\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\r\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\r\n * https://pinia.vuejs.org/ssr/nuxt.html.\r\n *\r\n * @example\r\n * ```js\r\n * import Vue from 'vue'\r\n * import { PiniaVuePlugin, createPinia } from 'pinia'\r\n *\r\n * Vue.use(PiniaVuePlugin)\r\n * const pinia = createPinia()\r\n *\r\n * new Vue({\r\n *   el: '#app',\r\n *   // ...\r\n *   pinia,\r\n * })\r\n * ```\r\n *\r\n * @param _Vue - `Vue` imported from 'vue'.\r\n */\n\n\nconst PiniaVuePlugin = function (_Vue) {\n  // Equivalent of\n  // app.config.globalProperties.$pinia = pinia\n  _Vue.mixin({\n    beforeCreate() {\n      const options = this.$options;\n\n      if (options.pinia) {\n        const pinia = options.pinia; // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L30\n\n        /* istanbul ignore else */\n\n        if (!this._provided) {\n          const provideCache = {};\n          Object.defineProperty(this, '_provided', {\n            get: () => provideCache,\n            set: v => Object.assign(provideCache, v)\n          });\n        }\n\n        this._provided[piniaSymbol] = pinia; // propagate the pinia instance in an SSR friendly way\n        // avoid adding it to nuxt twice\n\n        /* istanbul ignore else */\n\n        if (!this.$pinia) {\n          this.$pinia = pinia;\n        }\n\n        pinia._a = this;\n\n        if (IS_CLIENT) {\n          // this allows calling useStore() outside of a component setup after\n          // installing pinia's plugin\n          setActivePinia(pinia);\n\n          if (process.env.NODE_ENV !== 'production') {\n            registerPiniaDevtools(pinia._a, pinia);\n          }\n        }\n      } else if (!this.$pinia && options.parent && options.parent.$pinia) {\n        this.$pinia = options.parent.$pinia;\n      }\n    },\n\n    destroyed() {\n      delete this._pStores;\n    }\n\n  });\n};\n\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };","map":{"version":3,"sources":["/Users/liulu/åˆ˜ç’/vue3/hello-vue3/node_modules/pinia/dist/pinia.esm-browser.js"],"names":["getCurrentInstance","inject","toRaw","watch","unref","markRaw","effectScope","ref","isVue2","isRef","isReactive","set","onUnmounted","reactive","toRef","del","nextTick","computed","toRefs","setupDevtoolsPlugin","activePinia","setActivePinia","pinia","getActivePinia","piniaSymbol","process","env","NODE_ENV","Symbol","isPlainObject","o","Object","prototype","toString","call","toJSON","MutationType","IS_CLIENT","window","_global","self","global","globalThis","HTMLElement","bom","blob","autoBom","test","type","Blob","String","fromCharCode","download","url","name","opts","xhr","XMLHttpRequest","open","responseType","onload","saveAs","response","onerror","console","error","send","corsEnabled","e","status","click","node","dispatchEvent","MouseEvent","evt","document","createEvent","initMouseEvent","_navigator","navigator","userAgent","isMacOSWebView","HTMLAnchorElement","downloadSaveAs","msSaveAs","fileSaverSaveAs","a","createElement","rel","href","origin","location","target","URL","createObjectURL","setTimeout","revokeObjectURL","msSaveOrOpenBlob","popup","title","body","innerText","force","isSafari","isChromeIOS","FileReader","reader","onloadend","result","Error","replace","assign","readAsDataURL","toastMessage","message","piniaMessage","__VUE_DEVTOOLS_TOAST__","warn","log","isPinia","checkClipboardAccess","checkNotFocusedError","toLowerCase","includes","actionGlobalCopyState","clipboard","writeText","JSON","stringify","state","value","actionGlobalPasteState","parse","readText","actionGlobalSaveState","fileInput","getFileOpener","accept","openFile","Promise","resolve","reject","onchange","files","file","item","text","oncancel","actionGlobalOpenStateFile","formatDisplay","display","_custom","PINIA_ROOT_LABEL","PINIA_ROOT_ID","formatStoreForInspectorTree","store","id","label","$id","formatStoreForInspectorState","storeNames","Array","from","_s","keys","storeMap","map","storeId","editable","key","getters","filter","get","_getters","reduce","$state","length","getterName","_customProperties","size","customProperties","formatEventData","events","isArray","data","event","push","operations","oldValue","newValue","operation","formatMutationType","direct","patchFunction","patchObject","isTimelineActive","componentStateTypes","MUTATIONS_LAYER_ID","INSPECTOR_ID","getStoreType","registerPiniaDevtools","app","logo","packageName","homepage","api","now","addTimelineLayer","color","addInspector","icon","treeFilterPlaceholder","actions","action","tooltip","sendInspectorTree","sendInspectorState","on","inspectComponent","payload","ctx","proxy","componentInstance","_pStores","piniaStores","values","forEach","instanceData","_isOptionsAPI","$reset","getInspectorTree","inspectorId","stores","concat","rootNodes","getInspectorState","inspectedStore","nodeId","editInspectorState","path","has","unshift","editComponentState","startsWith","addStoreToDevtools","settings","logStoreChanges","defaultValue","bind","Date","$onAction","after","onError","args","groupId","runningActionId","addTimelineEvent","layerId","time","subtitle","activeAction","undefined","logType","notifyComponentUpdate","deep","$subscribe","eventData","detached","flush","hotUpdate","_hotUpdate","newStore","info","$dispose","getSettings","patchActionForGrouping","actionNames","storeActions","actionName","_actionId","trackedStore","Proxy","Reflect","apply","arguments","devtoolsPlugin","options","originalHotUpdate","_hmrPayload","createPinia","scope","run","_p","toBeInstalled","install","_a","provide","config","globalProperties","$pinia","plugin","use","_e","Map","isUseStore","fn","newState","oldState","subPatch","targetValue","acceptHMRUpdate","initialUseStore","hot","newModule","_pinia","exportName","useStore","invalidate","existingStore","noop","addSubscription","subscriptions","callback","onCleanup","removeSubscription","idx","indexOf","splice","triggerSubscriptions","slice","mergeReactiveObjects","patchToApply","hasOwnProperty","skipHydrateSymbol","skipHydrateMap","WeakMap","skipHydrate","obj","defineProperty","shouldHydrate","isComputed","effect","createOptionsStore","initialState","setup","localState","computedGetters","_r","createSetupStore","$patch","buildState","optionsForPlugin","active","$subscribeOptions","onTrigger","isListening","debuggerEvents","_hotUpdating","isSyncListening","actionSubscriptions","hotState","partialStateOrMutator","subscriptionMutation","then","stop","delete","wrapAction","afterCallbackList","onErrorCallbackList","ret","catch","partialStore","stopWatcher","Set","setupStore","prop","actionValue","stateKey","newStateTarget","oldStateSource","getter","getterValue","nonEnumerable","writable","configurable","enumerable","p","extender","extensions","add","constructor","hydrate","defineStore","idOrOptions","setupOptions","isSetupStore","currentInstance","_testing","hotId","vm","cache","mapStoreSuffix","setMapStoreSuffix","suffix","mapStores","reduced","mapState","keysOrMapper","storeKey","mapGetters","mapActions","mapWritableState","storeToRefs","refs","PiniaVuePlugin","_Vue","mixin","beforeCreate","$options","_provided","provideCache","v","parent","destroyed"],"mappings":"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","sourcesContent":["/*!\n  * pinia v2.0.13\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, onUnmounted, reactive, toRef, del, nextTick, computed, toRefs } from 'vue-demi';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\n/**\r\n * setActivePinia must be called to handle SSR at the top of functions like\r\n * `fetch`, `setup`, `serverPrefetch` and others\r\n */\r\nlet activePinia;\r\n/**\r\n * Sets or unsets the active pinia. Used in SSR and internally when calling\r\n * actions and getters\r\n *\r\n * @param pinia - Pinia instance\r\n */\r\nconst setActivePinia = (pinia) => (activePinia = pinia);\r\n/**\r\n * Get the currently active pinia if there is any.\r\n */\r\nconst getActivePinia = () => (getCurrentInstance() && inject(piniaSymbol)) || activePinia;\r\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\n\nfunction isPlainObject(\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\no) {\r\n    return (o &&\r\n        typeof o === 'object' &&\r\n        Object.prototype.toString.call(o) === '[object Object]' &&\r\n        typeof o.toJSON !== 'function');\r\n}\r\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\r\n// TODO: can we change these to numbers?\r\n/**\r\n * Possible types for SubscriptionCallback\r\n */\r\nvar MutationType;\r\n(function (MutationType) {\r\n    /**\r\n     * Direct mutation of the state:\r\n     *\r\n     * - `store.name = 'new name'`\r\n     * - `store.$state.name = 'new name'`\r\n     * - `store.list.push('new item')`\r\n     */\r\n    MutationType[\"direct\"] = \"direct\";\r\n    /**\r\n     * Mutated the state with `$patch` and an object\r\n     *\r\n     * - `store.$patch({ name: 'newName' })`\r\n     */\r\n    MutationType[\"patchObject\"] = \"patch object\";\r\n    /**\r\n     * Mutated the state with `$patch` and a function\r\n     *\r\n     * - `store.$patch(state => state.name = 'newName')`\r\n     */\r\n    MutationType[\"patchFunction\"] = \"patch function\";\r\n    // maybe reset? for $state = {} and $reset\r\n})(MutationType || (MutationType = {}));\n\nconst IS_CLIENT = typeof window !== 'undefined';\n\n/*\r\n * FileSaver.js A saveAs() FileSaver implementation.\r\n *\r\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\r\n * Morote.\r\n *\r\n * License : MIT\r\n */\r\n// The one and only way of getting global scope in all environments\r\n// https://stackoverflow.com/q/3277182/1008999\r\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\r\n    ? window\r\n    : typeof self === 'object' && self.self === self\r\n        ? self\r\n        : typeof global === 'object' && global.global === global\r\n            ? global\r\n            : typeof globalThis === 'object'\r\n                ? globalThis\r\n                : { HTMLElement: null })();\r\nfunction bom(blob, { autoBom = false } = {}) {\r\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\r\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\r\n    if (autoBom &&\r\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\r\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\r\n    }\r\n    return blob;\r\n}\r\nfunction download(url, name, opts) {\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url);\r\n    xhr.responseType = 'blob';\r\n    xhr.onload = function () {\r\n        saveAs(xhr.response, name, opts);\r\n    };\r\n    xhr.onerror = function () {\r\n        console.error('could not download file');\r\n    };\r\n    xhr.send();\r\n}\r\nfunction corsEnabled(url) {\r\n    const xhr = new XMLHttpRequest();\r\n    // use sync to avoid popup blocker\r\n    xhr.open('HEAD', url, false);\r\n    try {\r\n        xhr.send();\r\n    }\r\n    catch (e) { }\r\n    return xhr.status >= 200 && xhr.status <= 299;\r\n}\r\n// `a.click()` doesn't work for all browsers (#465)\r\nfunction click(node) {\r\n    try {\r\n        node.dispatchEvent(new MouseEvent('click'));\r\n    }\r\n    catch (e) {\r\n        const evt = document.createEvent('MouseEvents');\r\n        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\r\n        node.dispatchEvent(evt);\r\n    }\r\n}\r\nconst _navigator = \r\n typeof navigator === 'object' ? navigator : { userAgent: '' };\r\n// Detect WebView inside a native macOS app by ruling out all browsers\r\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\r\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\r\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\r\n    /AppleWebKit/.test(_navigator.userAgent) &&\r\n    !/Safari/.test(_navigator.userAgent))();\r\nconst saveAs = !IS_CLIENT\r\n    ? () => { } // noop\r\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\r\n        typeof HTMLAnchorElement !== 'undefined' &&\r\n            'download' in HTMLAnchorElement.prototype &&\r\n            !isMacOSWebView\r\n            ? downloadSaveAs\r\n            : // Use msSaveOrOpenBlob as a second approach\r\n                'msSaveOrOpenBlob' in _navigator\r\n                    ? msSaveAs\r\n                    : // Fallback to using FileReader and a popup\r\n                        fileSaverSaveAs;\r\nfunction downloadSaveAs(blob, name = 'download', opts) {\r\n    const a = document.createElement('a');\r\n    a.download = name;\r\n    a.rel = 'noopener'; // tabnabbing\r\n    // TODO: detect chrome extensions & packaged apps\r\n    // a.target = '_blank'\r\n    if (typeof blob === 'string') {\r\n        // Support regular links\r\n        a.href = blob;\r\n        if (a.origin !== location.origin) {\r\n            if (corsEnabled(a.href)) {\r\n                download(blob, name, opts);\r\n            }\r\n            else {\r\n                a.target = '_blank';\r\n                click(a);\r\n            }\r\n        }\r\n        else {\r\n            click(a);\r\n        }\r\n    }\r\n    else {\r\n        // Support blobs\r\n        a.href = URL.createObjectURL(blob);\r\n        setTimeout(function () {\r\n            URL.revokeObjectURL(a.href);\r\n        }, 4e4); // 40s\r\n        setTimeout(function () {\r\n            click(a);\r\n        }, 0);\r\n    }\r\n}\r\nfunction msSaveAs(blob, name = 'download', opts) {\r\n    if (typeof blob === 'string') {\r\n        if (corsEnabled(blob)) {\r\n            download(blob, name, opts);\r\n        }\r\n        else {\r\n            const a = document.createElement('a');\r\n            a.href = blob;\r\n            a.target = '_blank';\r\n            setTimeout(function () {\r\n                click(a);\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        // @ts-ignore: works on windows\r\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\r\n    }\r\n}\r\nfunction fileSaverSaveAs(blob, name, opts, popup) {\r\n    // Open a popup immediately do go around popup blocker\r\n    // Mostly only available on user interaction and the fileReader is async so...\r\n    popup = popup || open('', '_blank');\r\n    if (popup) {\r\n        popup.document.title = popup.document.body.innerText = 'downloading...';\r\n    }\r\n    if (typeof blob === 'string')\r\n        return download(blob, name, opts);\r\n    const force = blob.type === 'application/octet-stream';\r\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\r\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\r\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\r\n        typeof FileReader !== 'undefined') {\r\n        // Safari doesn't allow downloading of blob URLs\r\n        const reader = new FileReader();\r\n        reader.onloadend = function () {\r\n            let url = reader.result;\r\n            if (typeof url !== 'string') {\r\n                popup = null;\r\n                throw new Error('Wrong reader.result type');\r\n            }\r\n            url = isChromeIOS\r\n                ? url\r\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\r\n            if (popup) {\r\n                popup.location.href = url;\r\n            }\r\n            else {\r\n                location.assign(url);\r\n            }\r\n            popup = null; // reverse-tabnabbing #460\r\n        };\r\n        reader.readAsDataURL(blob);\r\n    }\r\n    else {\r\n        const url = URL.createObjectURL(blob);\r\n        if (popup)\r\n            popup.location.assign(url);\r\n        else\r\n            location.href = url;\r\n        popup = null; // reverse-tabnabbing #460\r\n        setTimeout(function () {\r\n            URL.revokeObjectURL(url);\r\n        }, 4e4); // 40s\r\n    }\r\n}\n\n/**\r\n * Shows a toast or console.log\r\n *\r\n * @param message - message to log\r\n * @param type - different color of the tooltip\r\n */\r\nfunction toastMessage(message, type) {\r\n    const piniaMessage = 'ðŸ ' + message;\r\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\r\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\r\n    }\r\n    else if (type === 'error') {\r\n        console.error(piniaMessage);\r\n    }\r\n    else if (type === 'warn') {\r\n        console.warn(piniaMessage);\r\n    }\r\n    else {\r\n        console.log(piniaMessage);\r\n    }\r\n}\r\nfunction isPinia(o) {\r\n    return '_a' in o && 'install' in o;\r\n}\n\nfunction checkClipboardAccess() {\r\n    if (!('clipboard' in navigator)) {\r\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\r\n        return true;\r\n    }\r\n}\r\nfunction checkNotFocusedError(error) {\r\n    if (error instanceof Error &&\r\n        error.message.toLowerCase().includes('document is not focused')) {\r\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nasync function actionGlobalCopyState(pinia) {\r\n    if (checkClipboardAccess())\r\n        return;\r\n    try {\r\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\r\n        toastMessage('Global state copied to clipboard.');\r\n    }\r\n    catch (error) {\r\n        if (checkNotFocusedError(error))\r\n            return;\r\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nasync function actionGlobalPasteState(pinia) {\r\n    if (checkClipboardAccess())\r\n        return;\r\n    try {\r\n        pinia.state.value = JSON.parse(await navigator.clipboard.readText());\r\n        toastMessage('Global state pasted from clipboard.');\r\n    }\r\n    catch (error) {\r\n        if (checkNotFocusedError(error))\r\n            return;\r\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nasync function actionGlobalSaveState(pinia) {\r\n    try {\r\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\r\n            type: 'text/plain;charset=utf-8',\r\n        }), 'pinia-state.json');\r\n    }\r\n    catch (error) {\r\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nlet fileInput;\r\nfunction getFileOpener() {\r\n    if (!fileInput) {\r\n        fileInput = document.createElement('input');\r\n        fileInput.type = 'file';\r\n        fileInput.accept = '.json';\r\n    }\r\n    function openFile() {\r\n        return new Promise((resolve, reject) => {\r\n            fileInput.onchange = async () => {\r\n                const files = fileInput.files;\r\n                if (!files)\r\n                    return resolve(null);\r\n                const file = files.item(0);\r\n                if (!file)\r\n                    return resolve(null);\r\n                return resolve({ text: await file.text(), file });\r\n            };\r\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\r\n            fileInput.oncancel = () => resolve(null);\r\n            fileInput.onerror = reject;\r\n            fileInput.click();\r\n        });\r\n    }\r\n    return openFile;\r\n}\r\nasync function actionGlobalOpenStateFile(pinia) {\r\n    try {\r\n        const open = await getFileOpener();\r\n        const result = await open();\r\n        if (!result)\r\n            return;\r\n        const { text, file } = result;\r\n        pinia.state.value = JSON.parse(text);\r\n        toastMessage(`Global state imported from \"${file.name}\".`);\r\n    }\r\n    catch (error) {\r\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\n\nfunction formatDisplay(display) {\r\n    return {\r\n        _custom: {\r\n            display,\r\n        },\r\n    };\r\n}\r\nconst PINIA_ROOT_LABEL = 'ðŸ Pinia (root)';\r\nconst PINIA_ROOT_ID = '_root';\r\nfunction formatStoreForInspectorTree(store) {\r\n    return isPinia(store)\r\n        ? {\r\n            id: PINIA_ROOT_ID,\r\n            label: PINIA_ROOT_LABEL,\r\n        }\r\n        : {\r\n            id: store.$id,\r\n            label: store.$id,\r\n        };\r\n}\r\nfunction formatStoreForInspectorState(store) {\r\n    if (isPinia(store)) {\r\n        const storeNames = Array.from(store._s.keys());\r\n        const storeMap = store._s;\r\n        const state = {\r\n            state: storeNames.map((storeId) => ({\r\n                editable: true,\r\n                key: storeId,\r\n                value: store.state.value[storeId],\r\n            })),\r\n            getters: storeNames\r\n                .filter((id) => storeMap.get(id)._getters)\r\n                .map((id) => {\r\n                const store = storeMap.get(id);\r\n                return {\r\n                    editable: false,\r\n                    key: id,\r\n                    value: store._getters.reduce((getters, key) => {\r\n                        getters[key] = store[key];\r\n                        return getters;\r\n                    }, {}),\r\n                };\r\n            }),\r\n        };\r\n        return state;\r\n    }\r\n    const state = {\r\n        state: Object.keys(store.$state).map((key) => ({\r\n            editable: true,\r\n            key,\r\n            value: store.$state[key],\r\n        })),\r\n    };\r\n    // avoid adding empty getters\r\n    if (store._getters && store._getters.length) {\r\n        state.getters = store._getters.map((getterName) => ({\r\n            editable: false,\r\n            key: getterName,\r\n            value: store[getterName],\r\n        }));\r\n    }\r\n    if (store._customProperties.size) {\r\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\r\n            editable: true,\r\n            key,\r\n            value: store[key],\r\n        }));\r\n    }\r\n    return state;\r\n}\r\nfunction formatEventData(events) {\r\n    if (!events)\r\n        return {};\r\n    if (Array.isArray(events)) {\r\n        // TODO: handle add and delete for arrays and objects\r\n        return events.reduce((data, event) => {\r\n            data.keys.push(event.key);\r\n            data.operations.push(event.type);\r\n            data.oldValue[event.key] = event.oldValue;\r\n            data.newValue[event.key] = event.newValue;\r\n            return data;\r\n        }, {\r\n            oldValue: {},\r\n            keys: [],\r\n            operations: [],\r\n            newValue: {},\r\n        });\r\n    }\r\n    else {\r\n        return {\r\n            operation: formatDisplay(events.type),\r\n            key: formatDisplay(events.key),\r\n            oldValue: events.oldValue,\r\n            newValue: events.newValue,\r\n        };\r\n    }\r\n}\r\nfunction formatMutationType(type) {\r\n    switch (type) {\r\n        case MutationType.direct:\r\n            return 'mutation';\r\n        case MutationType.patchFunction:\r\n            return '$patch';\r\n        case MutationType.patchObject:\r\n            return '$patch';\r\n        default:\r\n            return 'unknown';\r\n    }\r\n}\n\n// timeline can be paused when directly changing the state\r\nlet isTimelineActive = true;\r\nconst componentStateTypes = [];\r\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\r\nconst INSPECTOR_ID = 'pinia';\r\n/**\r\n * Gets the displayed name of a store in devtools\r\n *\r\n * @param id - id of the store\r\n * @returns a formatted string\r\n */\r\nconst getStoreType = (id) => 'ðŸ ' + id;\r\n/**\r\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\r\n * as soon as it is added to the application.\r\n *\r\n * @param app - Vue application\r\n * @param pinia - pinia instance\r\n */\r\nfunction registerPiniaDevtools(app, pinia) {\r\n    setupDevtoolsPlugin({\r\n        id: 'dev.esm.pinia',\r\n        label: 'Pinia ðŸ',\r\n        logo: 'https://pinia.vuejs.org/logo.svg',\r\n        packageName: 'pinia',\r\n        homepage: 'https://pinia.vuejs.org',\r\n        componentStateTypes,\r\n        app,\r\n    }, (api) => {\r\n        if (typeof api.now !== 'function') {\r\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\r\n        }\r\n        api.addTimelineLayer({\r\n            id: MUTATIONS_LAYER_ID,\r\n            label: `Pinia ðŸ`,\r\n            color: 0xe5df88,\r\n        });\r\n        api.addInspector({\r\n            id: INSPECTOR_ID,\r\n            label: 'Pinia ðŸ',\r\n            icon: 'storage',\r\n            treeFilterPlaceholder: 'Search stores',\r\n            actions: [\r\n                {\r\n                    icon: 'content_copy',\r\n                    action: () => {\r\n                        actionGlobalCopyState(pinia);\r\n                    },\r\n                    tooltip: 'Serialize and copy the state',\r\n                },\r\n                {\r\n                    icon: 'content_paste',\r\n                    action: async () => {\r\n                        await actionGlobalPasteState(pinia);\r\n                        api.sendInspectorTree(INSPECTOR_ID);\r\n                        api.sendInspectorState(INSPECTOR_ID);\r\n                    },\r\n                    tooltip: 'Replace the state with the content of your clipboard',\r\n                },\r\n                {\r\n                    icon: 'save',\r\n                    action: () => {\r\n                        actionGlobalSaveState(pinia);\r\n                    },\r\n                    tooltip: 'Save the state as a JSON file',\r\n                },\r\n                {\r\n                    icon: 'folder_open',\r\n                    action: async () => {\r\n                        await actionGlobalOpenStateFile(pinia);\r\n                        api.sendInspectorTree(INSPECTOR_ID);\r\n                        api.sendInspectorState(INSPECTOR_ID);\r\n                    },\r\n                    tooltip: 'Import the state from a JSON file',\r\n                },\r\n            ],\r\n        });\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            const proxy = (payload.componentInstance &&\r\n                payload.componentInstance.proxy);\r\n            if (proxy && proxy._pStores) {\r\n                const piniaStores = payload.componentInstance.proxy._pStores;\r\n                Object.values(piniaStores).forEach((store) => {\r\n                    payload.instanceData.state.push({\r\n                        type: getStoreType(store.$id),\r\n                        key: 'state',\r\n                        editable: true,\r\n                        value: store._isOptionsAPI\r\n                            ? {\r\n                                _custom: {\r\n                                    value: store.$state,\r\n                                    actions: [\r\n                                        {\r\n                                            icon: 'restore',\r\n                                            tooltip: 'Reset the state of this store',\r\n                                            action: () => store.$reset(),\r\n                                        },\r\n                                    ],\r\n                                },\r\n                            }\r\n                            : store.$state,\r\n                    });\r\n                    if (store._getters && store._getters.length) {\r\n                        payload.instanceData.state.push({\r\n                            type: getStoreType(store.$id),\r\n                            key: 'getters',\r\n                            editable: false,\r\n                            value: store._getters.reduce((getters, key) => {\r\n                                try {\r\n                                    getters[key] = store[key];\r\n                                }\r\n                                catch (error) {\r\n                                    // @ts-expect-error: we just want to show it in devtools\r\n                                    getters[key] = error;\r\n                                }\r\n                                return getters;\r\n                            }, {}),\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        api.on.getInspectorTree((payload) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                let stores = [pinia];\r\n                stores = stores.concat(Array.from(pinia._s.values()));\r\n                payload.rootNodes = (payload.filter\r\n                    ? stores.filter((store) => '$id' in store\r\n                        ? store.$id\r\n                            .toLowerCase()\r\n                            .includes(payload.filter.toLowerCase())\r\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\r\n                    : stores).map(formatStoreForInspectorTree);\r\n            }\r\n        });\r\n        api.on.getInspectorState((payload) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\r\n                    ? pinia\r\n                    : pinia._s.get(payload.nodeId);\r\n                if (!inspectedStore) {\r\n                    // this could be the selected store restored for a different project\r\n                    // so it's better not to say anything here\r\n                    return;\r\n                }\r\n                if (inspectedStore) {\r\n                    payload.state = formatStoreForInspectorState(inspectedStore);\r\n                }\r\n            }\r\n        });\r\n        api.on.editInspectorState((payload, ctx) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\r\n                    ? pinia\r\n                    : pinia._s.get(payload.nodeId);\r\n                if (!inspectedStore) {\r\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\r\n                }\r\n                const { path } = payload;\r\n                if (!isPinia(inspectedStore)) {\r\n                    // access only the state\r\n                    if (path.length !== 1 ||\r\n                        !inspectedStore._customProperties.has(path[0]) ||\r\n                        path[0] in inspectedStore.$state) {\r\n                        path.unshift('$state');\r\n                    }\r\n                }\r\n                else {\r\n                    // Root access, we can omit the `.value` because the devtools API does it for us\r\n                    path.unshift('state');\r\n                }\r\n                isTimelineActive = false;\r\n                payload.set(inspectedStore, path, payload.state.value);\r\n                isTimelineActive = true;\r\n            }\r\n        });\r\n        api.on.editComponentState((payload) => {\r\n            if (payload.type.startsWith('ðŸ')) {\r\n                const storeId = payload.type.replace(/^ðŸ\\s*/, '');\r\n                const store = pinia._s.get(storeId);\r\n                if (!store) {\r\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\r\n                }\r\n                const { path } = payload;\r\n                if (path[0] !== 'state') {\r\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\r\n                }\r\n                // rewrite the first entry to be able to directly set the state as\r\n                // well as any other path\r\n                path[0] = '$state';\r\n                isTimelineActive = false;\r\n                payload.set(store, path, payload.state.value);\r\n                isTimelineActive = true;\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction addStoreToDevtools(app, store) {\r\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\r\n        componentStateTypes.push(getStoreType(store.$id));\r\n    }\r\n    setupDevtoolsPlugin({\r\n        id: 'dev.esm.pinia',\r\n        label: 'Pinia ðŸ',\r\n        logo: 'https://pinia.vuejs.org/logo.svg',\r\n        packageName: 'pinia',\r\n        homepage: 'https://pinia.vuejs.org',\r\n        componentStateTypes,\r\n        app,\r\n        settings: {\r\n            logStoreChanges: {\r\n                label: 'Notify about new/deleted stores',\r\n                type: 'boolean',\r\n                defaultValue: true,\r\n            },\r\n            // useEmojis: {\r\n            //   label: 'Use emojis in messages âš¡ï¸',\r\n            //   type: 'boolean',\r\n            //   defaultValue: true,\r\n            // },\r\n        },\r\n    }, (api) => {\r\n        // gracefully handle errors\r\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\r\n        store.$onAction(({ after, onError, name, args }) => {\r\n            const groupId = runningActionId++;\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: {\r\n                    time: now(),\r\n                    title: 'ðŸ›« ' + name,\r\n                    subtitle: 'start',\r\n                    data: {\r\n                        store: formatDisplay(store.$id),\r\n                        action: formatDisplay(name),\r\n                        args,\r\n                    },\r\n                    groupId,\r\n                },\r\n            });\r\n            after((result) => {\r\n                activeAction = undefined;\r\n                api.addTimelineEvent({\r\n                    layerId: MUTATIONS_LAYER_ID,\r\n                    event: {\r\n                        time: now(),\r\n                        title: 'ðŸ›¬ ' + name,\r\n                        subtitle: 'end',\r\n                        data: {\r\n                            store: formatDisplay(store.$id),\r\n                            action: formatDisplay(name),\r\n                            args,\r\n                            result,\r\n                        },\r\n                        groupId,\r\n                    },\r\n                });\r\n            });\r\n            onError((error) => {\r\n                activeAction = undefined;\r\n                api.addTimelineEvent({\r\n                    layerId: MUTATIONS_LAYER_ID,\r\n                    event: {\r\n                        time: now(),\r\n                        logType: 'error',\r\n                        title: 'ðŸ’¥ ' + name,\r\n                        subtitle: 'end',\r\n                        data: {\r\n                            store: formatDisplay(store.$id),\r\n                            action: formatDisplay(name),\r\n                            args,\r\n                            error,\r\n                        },\r\n                        groupId,\r\n                    },\r\n                });\r\n            });\r\n        }, true);\r\n        store._customProperties.forEach((name) => {\r\n            watch(() => unref(store[name]), (newValue, oldValue) => {\r\n                api.notifyComponentUpdate();\r\n                api.sendInspectorState(INSPECTOR_ID);\r\n                if (isTimelineActive) {\r\n                    api.addTimelineEvent({\r\n                        layerId: MUTATIONS_LAYER_ID,\r\n                        event: {\r\n                            time: now(),\r\n                            title: 'Change',\r\n                            subtitle: name,\r\n                            data: {\r\n                                newValue,\r\n                                oldValue,\r\n                            },\r\n                            groupId: activeAction,\r\n                        },\r\n                    });\r\n                }\r\n            }, { deep: true });\r\n        });\r\n        store.$subscribe(({ events, type }, state) => {\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n            if (!isTimelineActive)\r\n                return;\r\n            // rootStore.state[store.id] = state\r\n            const eventData = {\r\n                time: now(),\r\n                title: formatMutationType(type),\r\n                data: {\r\n                    store: formatDisplay(store.$id),\r\n                    ...formatEventData(events),\r\n                },\r\n                groupId: activeAction,\r\n            };\r\n            // reset for the next mutation\r\n            activeAction = undefined;\r\n            if (type === MutationType.patchFunction) {\r\n                eventData.subtitle = 'â¤µï¸';\r\n            }\r\n            else if (type === MutationType.patchObject) {\r\n                eventData.subtitle = 'ðŸ§©';\r\n            }\r\n            else if (events && !Array.isArray(events)) {\r\n                eventData.subtitle = events.type;\r\n            }\r\n            if (events) {\r\n                eventData.data['rawEvent(s)'] = {\r\n                    _custom: {\r\n                        display: 'DebuggerEvent',\r\n                        type: 'object',\r\n                        tooltip: 'raw DebuggerEvent[]',\r\n                        value: events,\r\n                    },\r\n                };\r\n            }\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: eventData,\r\n            });\r\n        }, { detached: true, flush: 'sync' });\r\n        const hotUpdate = store._hotUpdate;\r\n        store._hotUpdate = markRaw((newStore) => {\r\n            hotUpdate(newStore);\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: {\r\n                    time: now(),\r\n                    title: 'ðŸ”¥ ' + store.$id,\r\n                    subtitle: 'HMR update',\r\n                    data: {\r\n                        store: formatDisplay(store.$id),\r\n                        info: formatDisplay(`HMR update`),\r\n                    },\r\n                },\r\n            });\r\n            // update the devtools too\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(INSPECTOR_ID);\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n        });\r\n        const { $dispose } = store;\r\n        store.$dispose = () => {\r\n            $dispose();\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(INSPECTOR_ID);\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n            api.getSettings().logStoreChanges &&\r\n                toastMessage(`Disposed \"${store.$id}\" store ðŸ—‘`);\r\n        };\r\n        // trigger an update so it can display new registered stores\r\n        api.notifyComponentUpdate();\r\n        api.sendInspectorTree(INSPECTOR_ID);\r\n        api.sendInspectorState(INSPECTOR_ID);\r\n        api.getSettings().logStoreChanges &&\r\n            toastMessage(`\"${store.$id}\" store installed ðŸ†•`);\r\n    });\r\n}\r\nlet runningActionId = 0;\r\nlet activeAction;\r\n/**\r\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\r\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\r\n * mutation to the action.\r\n *\r\n * @param store - store to patch\r\n * @param actionNames - list of actionst to patch\r\n */\r\nfunction patchActionForGrouping(store, actionNames) {\r\n    // original actions of the store as they are given by pinia. We are going to override them\r\n    const actions = actionNames.reduce((storeActions, actionName) => {\r\n        // use toRaw to avoid tracking #541\r\n        storeActions[actionName] = toRaw(store)[actionName];\r\n        return storeActions;\r\n    }, {});\r\n    for (const actionName in actions) {\r\n        store[actionName] = function () {\r\n            // setActivePinia(store._p)\r\n            // the running action id is incremented in a before action hook\r\n            const _actionId = runningActionId;\r\n            const trackedStore = new Proxy(store, {\r\n                get(...args) {\r\n                    activeAction = _actionId;\r\n                    return Reflect.get(...args);\r\n                },\r\n                set(...args) {\r\n                    activeAction = _actionId;\r\n                    return Reflect.set(...args);\r\n                },\r\n            });\r\n            return actions[actionName].apply(trackedStore, arguments);\r\n        };\r\n    }\r\n}\r\n/**\r\n * pinia.use(devtoolsPlugin)\r\n */\r\nfunction devtoolsPlugin({ app, store, options }) {\r\n    // HMR module\r\n    if (store.$id.startsWith('__hot:')) {\r\n        return;\r\n    }\r\n    // detect option api vs setup api\r\n    if (options.state) {\r\n        store._isOptionsAPI = true;\r\n    }\r\n    // only wrap actions in option-defined stores as this technique relies on\r\n    // wrapping the context of the action with a proxy\r\n    if (typeof options.state === 'function') {\r\n        patchActionForGrouping(\r\n        // @ts-expect-error: can cast the store...\r\n        store, Object.keys(options.actions));\r\n        const originalHotUpdate = store._hotUpdate;\r\n        // Upgrade the HMR to also update the new actions\r\n        toRaw(store)._hotUpdate = function (newStore) {\r\n            originalHotUpdate.apply(this, arguments);\r\n            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions));\r\n        };\r\n    }\r\n    addStoreToDevtools(app, \r\n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\r\n    store);\r\n}\n\n/**\r\n * Creates a Pinia instance to be used by the application\r\n */\r\nfunction createPinia() {\r\n    const scope = effectScope(true);\r\n    // NOTE: here we could check the window object for a state and directly set it\r\n    // if there is anything like it with Vue 3 SSR\r\n    const state = scope.run(() => ref({}));\r\n    let _p = [];\r\n    // plugins added before calling app.use(pinia)\r\n    let toBeInstalled = [];\r\n    const pinia = markRaw({\r\n        install(app) {\r\n            // this allows calling useStore() outside of a component setup after\r\n            // installing pinia's plugin\r\n            setActivePinia(pinia);\r\n            if (!isVue2) {\r\n                pinia._a = app;\r\n                app.provide(piniaSymbol, pinia);\r\n                app.config.globalProperties.$pinia = pinia;\r\n                /* istanbul ignore else */\r\n                if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\r\n                    registerPiniaDevtools(app, pinia);\r\n                }\r\n                toBeInstalled.forEach((plugin) => _p.push(plugin));\r\n                toBeInstalled = [];\r\n            }\r\n        },\r\n        use(plugin) {\r\n            if (!this._a && !isVue2) {\r\n                toBeInstalled.push(plugin);\r\n            }\r\n            else {\r\n                _p.push(plugin);\r\n            }\r\n            return this;\r\n        },\r\n        _p,\r\n        // it's actually undefined here\r\n        // @ts-expect-error\r\n        _a: null,\r\n        _e: scope,\r\n        _s: new Map(),\r\n        state,\r\n    });\r\n    // pinia devtools rely on dev only features so they cannot be forced unless\r\n    // the dev build of Vue is used\r\n    if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\r\n        pinia.use(devtoolsPlugin);\r\n    }\r\n    return pinia;\r\n}\n\n/**\r\n * Checks if a function is a `StoreDefinition`.\r\n *\r\n * @param fn - object to test\r\n * @returns true if `fn` is a StoreDefinition\r\n */\r\nconst isUseStore = (fn) => {\r\n    return typeof fn === 'function' && typeof fn.$id === 'string';\r\n};\r\n/**\r\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\r\n * remove any key not existing in `newState` and recursively merge plain\r\n * objects.\r\n *\r\n * @param newState - new state object to be patched\r\n * @param oldState - old state that should be used to patch newState\r\n * @returns - newState\r\n */\r\nfunction patchObject(newState, oldState) {\r\n    // no need to go through symbols because they cannot be serialized anyway\r\n    for (const key in oldState) {\r\n        const subPatch = oldState[key];\r\n        // skip the whole sub tree\r\n        if (!(key in newState)) {\r\n            continue;\r\n        }\r\n        const targetValue = newState[key];\r\n        if (isPlainObject(targetValue) &&\r\n            isPlainObject(subPatch) &&\r\n            !isRef(subPatch) &&\r\n            !isReactive(subPatch)) {\r\n            newState[key] = patchObject(targetValue, subPatch);\r\n        }\r\n        else {\r\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\r\n            // just set the whole thing\r\n            if (isVue2) {\r\n                set(newState, key, subPatch);\r\n            }\r\n            else {\r\n                newState[key] = subPatch;\r\n            }\r\n        }\r\n    }\r\n    return newState;\r\n}\r\n/**\r\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\r\n *\r\n * @example\r\n * ```js\r\n * const useUser = defineStore(...)\r\n * if (import.meta.hot) {\r\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\r\n * }\r\n * ```\r\n *\r\n * @param initialUseStore - return of the defineStore to hot update\r\n * @param hot - `import.meta.hot`\r\n */\r\nfunction acceptHMRUpdate(initialUseStore, hot) {\r\n    return (newModule) => {\r\n        const pinia = hot.data.pinia || initialUseStore._pinia;\r\n        if (!pinia) {\r\n            // this store is still not used\r\n            return;\r\n        }\r\n        // preserve the pinia instance across loads\r\n        hot.data.pinia = pinia;\r\n        // console.log('got data', newStore)\r\n        for (const exportName in newModule) {\r\n            const useStore = newModule[exportName];\r\n            // console.log('checking for', exportName)\r\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\r\n                // console.log('Accepting update for', useStore.$id)\r\n                const id = useStore.$id;\r\n                if (id !== initialUseStore.$id) {\r\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\r\n                    // return import.meta.hot.invalidate()\r\n                    return hot.invalidate();\r\n                }\r\n                const existingStore = pinia._s.get(id);\r\n                if (!existingStore) {\r\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\r\n                    return;\r\n                }\r\n                useStore(pinia, existingStore);\r\n            }\r\n        }\r\n    };\r\n}\n\nconst noop = () => { };\r\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\r\n    subscriptions.push(callback);\r\n    const removeSubscription = () => {\r\n        const idx = subscriptions.indexOf(callback);\r\n        if (idx > -1) {\r\n            subscriptions.splice(idx, 1);\r\n            onCleanup();\r\n        }\r\n    };\r\n    if (!detached && getCurrentInstance()) {\r\n        onUnmounted(removeSubscription);\r\n    }\r\n    return removeSubscription;\r\n}\r\nfunction triggerSubscriptions(subscriptions, ...args) {\r\n    subscriptions.slice().forEach((callback) => {\r\n        callback(...args);\r\n    });\r\n}\n\nfunction mergeReactiveObjects(target, patchToApply) {\r\n    // no need to go through symbols because they cannot be serialized anyway\r\n    for (const key in patchToApply) {\r\n        if (!patchToApply.hasOwnProperty(key))\r\n            continue;\r\n        const subPatch = patchToApply[key];\r\n        const targetValue = target[key];\r\n        if (isPlainObject(targetValue) &&\r\n            isPlainObject(subPatch) &&\r\n            target.hasOwnProperty(key) &&\r\n            !isRef(subPatch) &&\r\n            !isReactive(subPatch)) {\r\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\r\n        }\r\n        else {\r\n            // @ts-expect-error: subPatch is a valid value\r\n            target[key] = subPatch;\r\n        }\r\n    }\r\n    return target;\r\n}\r\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\r\n    ? Symbol('pinia:skipHydration')\r\n    : /* istanbul ignore next */ Symbol();\r\nconst skipHydrateMap = /*#__PURE__*/ new WeakMap();\r\nfunction skipHydrate(obj) {\r\n    return isVue2\r\n        ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\r\n            /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj\r\n        : Object.defineProperty(obj, skipHydrateSymbol, {});\r\n}\r\nfunction shouldHydrate(obj) {\r\n    return isVue2\r\n        ? /* istanbul ignore next */ !skipHydrateMap.has(obj)\r\n        : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\r\n}\r\nconst { assign } = Object;\r\nfunction isComputed(o) {\r\n    return !!(isRef(o) && o.effect);\r\n}\r\nfunction createOptionsStore(id, options, pinia, hot) {\r\n    const { state, actions, getters } = options;\r\n    const initialState = pinia.state.value[id];\r\n    let store;\r\n    function setup() {\r\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\r\n            /* istanbul ignore if */\r\n            if (isVue2) {\r\n                set(pinia.state.value, id, state ? state() : {});\r\n            }\r\n            else {\r\n                pinia.state.value[id] = state ? state() : {};\r\n            }\r\n        }\r\n        // avoid creating a state in pinia.state.value\r\n        const localState = (process.env.NODE_ENV !== 'production') && hot\r\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\r\n                toRefs(ref(state ? state() : {}).value)\r\n            : toRefs(pinia.state.value[id]);\r\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\r\n            computedGetters[name] = markRaw(computed(() => {\r\n                setActivePinia(pinia);\r\n                // it was created just before\r\n                const store = pinia._s.get(id);\r\n                // allow cross using stores\r\n                /* istanbul ignore next */\r\n                if (isVue2 && !store._r)\r\n                    return;\r\n                // @ts-expect-error\r\n                // return getters![name].call(context, context)\r\n                // TODO: avoid reading the getter while assigning with a global variable\r\n                return getters[name].call(store, store);\r\n            }));\r\n            return computedGetters;\r\n        }, {}));\r\n    }\r\n    store = createSetupStore(id, setup, options, pinia, hot);\r\n    store.$reset = function $reset() {\r\n        const newState = state ? state() : {};\r\n        // we use a patch to group all changes into one single subscription\r\n        this.$patch(($state) => {\r\n            assign($state, newState);\r\n        });\r\n    };\r\n    return store;\r\n}\r\nfunction createSetupStore($id, setup, options = {}, pinia, hot) {\r\n    let scope;\r\n    const buildState = options.state;\r\n    const optionsForPlugin = assign({ actions: {} }, options);\r\n    /* istanbul ignore if */\r\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\r\n        throw new Error('Pinia destroyed');\r\n    }\r\n    // watcher options for $subscribe\r\n    const $subscribeOptions = {\r\n        deep: true,\r\n        // flush: 'post',\r\n    };\r\n    /* istanbul ignore else */\r\n    if ((process.env.NODE_ENV !== 'production') && !isVue2) {\r\n        $subscribeOptions.onTrigger = (event) => {\r\n            /* istanbul ignore else */\r\n            if (isListening) {\r\n                debuggerEvents = event;\r\n                // avoid triggering this while the store is being built and the state is being set in pinia\r\n            }\r\n            else if (isListening == false && !store._hotUpdating) {\r\n                // let patch send all the events together later\r\n                /* istanbul ignore else */\r\n                if (Array.isArray(debuggerEvents)) {\r\n                    debuggerEvents.push(event);\r\n                }\r\n                else {\r\n                    console.error('ðŸ debuggerEvents should be an array. This is most likely an internal Pinia bug.');\r\n                }\r\n            }\r\n        };\r\n    }\r\n    // internal state\r\n    let isListening; // set to true at the end\r\n    let isSyncListening; // set to true at the end\r\n    let subscriptions = markRaw([]);\r\n    let actionSubscriptions = markRaw([]);\r\n    let debuggerEvents;\r\n    const initialState = pinia.state.value[$id];\r\n    // avoid setting the state for option stores are it is set\r\n    // by the setup\r\n    if (!buildState && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\r\n        /* istanbul ignore if */\r\n        if (isVue2) {\r\n            set(pinia.state.value, $id, {});\r\n        }\r\n        else {\r\n            pinia.state.value[$id] = {};\r\n        }\r\n    }\r\n    const hotState = ref({});\r\n    function $patch(partialStateOrMutator) {\r\n        let subscriptionMutation;\r\n        isListening = isSyncListening = false;\r\n        // reset the debugger events since patches are sync\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            debuggerEvents = [];\r\n        }\r\n        if (typeof partialStateOrMutator === 'function') {\r\n            partialStateOrMutator(pinia.state.value[$id]);\r\n            subscriptionMutation = {\r\n                type: MutationType.patchFunction,\r\n                storeId: $id,\r\n                events: debuggerEvents,\r\n            };\r\n        }\r\n        else {\r\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\r\n            subscriptionMutation = {\r\n                type: MutationType.patchObject,\r\n                payload: partialStateOrMutator,\r\n                storeId: $id,\r\n                events: debuggerEvents,\r\n            };\r\n        }\r\n        nextTick().then(() => {\r\n            isListening = true;\r\n        });\r\n        isSyncListening = true;\r\n        // because we paused the watcher, we need to manually call the subscriptions\r\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\r\n    }\r\n    /* istanbul ignore next */\r\n    const $reset = (process.env.NODE_ENV !== 'production')\r\n        ? () => {\r\n            throw new Error(`ðŸ: Store \"${$id}\" is build using the setup syntax and does not implement $reset().`);\r\n        }\r\n        : noop;\r\n    function $dispose() {\r\n        scope.stop();\r\n        subscriptions = [];\r\n        actionSubscriptions = [];\r\n        pinia._s.delete($id);\r\n    }\r\n    /**\r\n     * Wraps an action to handle subscriptions.\r\n     *\r\n     * @param name - name of the action\r\n     * @param action - action to wrap\r\n     * @returns a wrapped action to handle subscriptions\r\n     */\r\n    function wrapAction(name, action) {\r\n        return function () {\r\n            setActivePinia(pinia);\r\n            const args = Array.from(arguments);\r\n            const afterCallbackList = [];\r\n            const onErrorCallbackList = [];\r\n            function after(callback) {\r\n                afterCallbackList.push(callback);\r\n            }\r\n            function onError(callback) {\r\n                onErrorCallbackList.push(callback);\r\n            }\r\n            // @ts-expect-error\r\n            triggerSubscriptions(actionSubscriptions, {\r\n                args,\r\n                name,\r\n                store,\r\n                after,\r\n                onError,\r\n            });\r\n            let ret;\r\n            try {\r\n                ret = action.apply(this && this.$id === $id ? this : store, args);\r\n                // handle sync errors\r\n            }\r\n            catch (error) {\r\n                triggerSubscriptions(onErrorCallbackList, error);\r\n                throw error;\r\n            }\r\n            if (ret instanceof Promise) {\r\n                return ret\r\n                    .then((value) => {\r\n                    triggerSubscriptions(afterCallbackList, value);\r\n                    return value;\r\n                })\r\n                    .catch((error) => {\r\n                    triggerSubscriptions(onErrorCallbackList, error);\r\n                    return Promise.reject(error);\r\n                });\r\n            }\r\n            // allow the afterCallback to override the return value\r\n            triggerSubscriptions(afterCallbackList, ret);\r\n            return ret;\r\n        };\r\n    }\r\n    const _hmrPayload = /*#__PURE__*/ markRaw({\r\n        actions: {},\r\n        getters: {},\r\n        state: [],\r\n        hotState,\r\n    });\r\n    const partialStore = {\r\n        _p: pinia,\r\n        // _s: scope,\r\n        $id,\r\n        $onAction: addSubscription.bind(null, actionSubscriptions),\r\n        $patch,\r\n        $reset,\r\n        $subscribe(callback, options = {}) {\r\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\r\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\r\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\r\n                    callback({\r\n                        storeId: $id,\r\n                        type: MutationType.direct,\r\n                        events: debuggerEvents,\r\n                    }, state);\r\n                }\r\n            }, assign({}, $subscribeOptions, options)));\r\n            return removeSubscription;\r\n        },\r\n        $dispose,\r\n    };\r\n    /* istanbul ignore if */\r\n    if (isVue2) {\r\n        // start as non ready\r\n        partialStore._r = false;\r\n    }\r\n    const store = reactive(assign((process.env.NODE_ENV !== 'production') && IS_CLIENT\r\n        ? // devtools custom properties\r\n            {\r\n                _customProperties: markRaw(new Set()),\r\n                _hmrPayload,\r\n            }\r\n        : {}, partialStore\r\n    // must be added later\r\n    // setupStore\r\n    ));\r\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\r\n    // creating infinite loops.\r\n    pinia._s.set($id, store);\r\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\r\n    const setupStore = pinia._e.run(() => {\r\n        scope = effectScope();\r\n        return scope.run(() => setup());\r\n    });\r\n    // overwrite existing actions to support $onAction\r\n    for (const key in setupStore) {\r\n        const prop = setupStore[key];\r\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\r\n            // mark it as a piece of state to be serialized\r\n            if ((process.env.NODE_ENV !== 'production') && hot) {\r\n                set(hotState.value, key, toRef(setupStore, key));\r\n                // createOptionStore directly sets the state in pinia.state.value so we\r\n                // can just skip that\r\n            }\r\n            else if (!buildState) {\r\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\r\n                if (initialState && shouldHydrate(prop)) {\r\n                    if (isRef(prop)) {\r\n                        prop.value = initialState[key];\r\n                    }\r\n                    else {\r\n                        // probably a reactive object, lets recursively assign\r\n                        mergeReactiveObjects(prop, initialState[key]);\r\n                    }\r\n                }\r\n                // transfer the ref to the pinia state to keep everything in sync\r\n                /* istanbul ignore if */\r\n                if (isVue2) {\r\n                    set(pinia.state.value[$id], key, prop);\r\n                }\r\n                else {\r\n                    pinia.state.value[$id][key] = prop;\r\n                }\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                _hmrPayload.state.push(key);\r\n            }\r\n            // action\r\n        }\r\n        else if (typeof prop === 'function') {\r\n            // @ts-expect-error: we are overriding the function we avoid wrapping if\r\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : wrapAction(key, prop);\r\n            // this a hot module replacement store because the hotUpdate method needs\r\n            // to do it with the right context\r\n            /* istanbul ignore if */\r\n            if (isVue2) {\r\n                set(setupStore, key, actionValue);\r\n            }\r\n            else {\r\n                // @ts-expect-error\r\n                setupStore[key] = actionValue;\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                _hmrPayload.actions[key] = prop;\r\n            }\r\n            // list actions so they can be used in plugins\r\n            // @ts-expect-error\r\n            optionsForPlugin.actions[key] = prop;\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            // add getters for devtools\r\n            if (isComputed(prop)) {\r\n                _hmrPayload.getters[key] = buildState\r\n                    ? // @ts-expect-error\r\n                        options.getters[key]\r\n                    : prop;\r\n                if (IS_CLIENT) {\r\n                    const getters = \r\n                    // @ts-expect-error: it should be on the store\r\n                    setupStore._getters || (setupStore._getters = markRaw([]));\r\n                    getters.push(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // add the state, getters, and action properties\r\n    /* istanbul ignore if */\r\n    if (isVue2) {\r\n        Object.keys(setupStore).forEach((key) => {\r\n            set(store, key, \r\n            // @ts-expect-error: valid key indexing\r\n            setupStore[key]);\r\n        });\r\n    }\r\n    else {\r\n        assign(store, setupStore);\r\n        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\r\n        // Make `storeToRefs()` work with `reactive()` #799\r\n        assign(toRaw(store), setupStore);\r\n    }\r\n    // use this instead of a computed with setter to be able to create it anywhere\r\n    // without linking the computed lifespan to wherever the store is first\r\n    // created.\r\n    Object.defineProperty(store, '$state', {\r\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\r\n        set: (state) => {\r\n            /* istanbul ignore if */\r\n            if ((process.env.NODE_ENV !== 'production') && hot) {\r\n                throw new Error('cannot set hotState');\r\n            }\r\n            $patch(($state) => {\r\n                assign($state, state);\r\n            });\r\n        },\r\n    });\r\n    // add the hotUpdate before plugins to allow them to override it\r\n    /* istanbul ignore else */\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        store._hotUpdate = markRaw((newStore) => {\r\n            store._hotUpdating = true;\r\n            newStore._hmrPayload.state.forEach((stateKey) => {\r\n                if (stateKey in store.$state) {\r\n                    const newStateTarget = newStore.$state[stateKey];\r\n                    const oldStateSource = store.$state[stateKey];\r\n                    if (typeof newStateTarget === 'object' &&\r\n                        isPlainObject(newStateTarget) &&\r\n                        isPlainObject(oldStateSource)) {\r\n                        patchObject(newStateTarget, oldStateSource);\r\n                    }\r\n                    else {\r\n                        // transfer the ref\r\n                        newStore.$state[stateKey] = oldStateSource;\r\n                    }\r\n                }\r\n                // patch direct access properties to allow store.stateProperty to work as\r\n                // store.$state.stateProperty\r\n                set(store, stateKey, toRef(newStore.$state, stateKey));\r\n            });\r\n            // remove deleted state properties\r\n            Object.keys(store.$state).forEach((stateKey) => {\r\n                if (!(stateKey in newStore.$state)) {\r\n                    del(store, stateKey);\r\n                }\r\n            });\r\n            // avoid devtools logging this as a mutation\r\n            isListening = false;\r\n            isSyncListening = false;\r\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\r\n            isSyncListening = true;\r\n            nextTick().then(() => {\r\n                isListening = true;\r\n            });\r\n            for (const actionName in newStore._hmrPayload.actions) {\r\n                const action = newStore[actionName];\r\n                set(store, actionName, wrapAction(actionName, action));\r\n            }\r\n            // TODO: does this work in both setup and option store?\r\n            for (const getterName in newStore._hmrPayload.getters) {\r\n                const getter = newStore._hmrPayload.getters[getterName];\r\n                const getterValue = buildState\r\n                    ? // special handling of options api\r\n                        computed(() => {\r\n                            setActivePinia(pinia);\r\n                            return getter.call(store, store);\r\n                        })\r\n                    : getter;\r\n                set(store, getterName, getterValue);\r\n            }\r\n            // remove deleted getters\r\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\r\n                if (!(key in newStore._hmrPayload.getters)) {\r\n                    del(store, key);\r\n                }\r\n            });\r\n            // remove old actions\r\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\r\n                if (!(key in newStore._hmrPayload.actions)) {\r\n                    del(store, key);\r\n                }\r\n            });\r\n            // update the values used in devtools and to allow deleting new properties later on\r\n            store._hmrPayload = newStore._hmrPayload;\r\n            store._getters = newStore._getters;\r\n            store._hotUpdating = false;\r\n        });\r\n        const nonEnumerable = {\r\n            writable: true,\r\n            configurable: true,\r\n            // avoid warning on devtools trying to display this property\r\n            enumerable: false,\r\n        };\r\n        if (IS_CLIENT) {\r\n            ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\r\n                Object.defineProperty(store, p, {\r\n                    value: store[p],\r\n                    ...nonEnumerable,\r\n                });\r\n            });\r\n        }\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isVue2) {\r\n        // mark the store as ready before plugins\r\n        store._r = true;\r\n    }\r\n    // apply all plugins\r\n    pinia._p.forEach((extender) => {\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\r\n            const extensions = scope.run(() => extender({\r\n                store,\r\n                app: pinia._a,\r\n                pinia,\r\n                options: optionsForPlugin,\r\n            }));\r\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\r\n            assign(store, extensions);\r\n        }\r\n        else {\r\n            assign(store, scope.run(() => extender({\r\n                store,\r\n                app: pinia._a,\r\n                pinia,\r\n                options: optionsForPlugin,\r\n            })));\r\n        }\r\n    });\r\n    if ((process.env.NODE_ENV !== 'production') &&\r\n        store.$state &&\r\n        typeof store.$state === 'object' &&\r\n        typeof store.$state.constructor === 'function' &&\r\n        !store.$state.constructor.toString().includes('[native code]')) {\r\n        console.warn(`[ðŸ]: The \"state\" must be a plain object. It cannot be\\n` +\r\n            `\\tstate: () => new MyClass()\\n` +\r\n            `Found in store \"${store.$id}\".`);\r\n    }\r\n    // only apply hydrate to option stores with an initial state in pinia\r\n    if (initialState &&\r\n        buildState &&\r\n        options.hydrate) {\r\n        options.hydrate(store.$state, initialState);\r\n    }\r\n    isListening = true;\r\n    isSyncListening = true;\r\n    return store;\r\n}\r\nfunction defineStore(\r\n// TODO: add proper types from above\r\nidOrOptions, setup, setupOptions) {\r\n    let id;\r\n    let options;\r\n    const isSetupStore = typeof setup === 'function';\r\n    if (typeof idOrOptions === 'string') {\r\n        id = idOrOptions;\r\n        // the option store setup will contain the actual options in this case\r\n        options = isSetupStore ? setupOptions : setup;\r\n    }\r\n    else {\r\n        options = idOrOptions;\r\n        id = idOrOptions.id;\r\n    }\r\n    function useStore(pinia, hot) {\r\n        const currentInstance = getCurrentInstance();\r\n        pinia =\r\n            // in test mode, ignore the argument provided as we can always retrieve a\r\n            // pinia instance with getActivePinia()\r\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\r\n                (currentInstance && inject(piniaSymbol));\r\n        if (pinia)\r\n            setActivePinia(pinia);\r\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\r\n            throw new Error(`[ðŸ]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\\n` +\r\n                `\\tconst pinia = createPinia()\\n` +\r\n                `\\tapp.use(pinia)\\n` +\r\n                `This will fail in production.`);\r\n        }\r\n        pinia = activePinia;\r\n        if (!pinia._s.has(id)) {\r\n            // creating the store registers it in `pinia._s`\r\n            if (isSetupStore) {\r\n                createSetupStore(id, setup, options, pinia);\r\n            }\r\n            else {\r\n                createOptionsStore(id, options, pinia);\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                // @ts-expect-error: not the right inferred type\r\n                useStore._pinia = pinia;\r\n            }\r\n        }\r\n        const store = pinia._s.get(id);\r\n        if ((process.env.NODE_ENV !== 'production') && hot) {\r\n            const hotId = '__hot:' + id;\r\n            const newStore = isSetupStore\r\n                ? createSetupStore(hotId, setup, options, pinia, true)\r\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\r\n            hot._hotUpdate(newStore);\r\n            // cleanup the state properties and the store from the cache\r\n            delete pinia.state.value[hotId];\r\n            pinia._s.delete(hotId);\r\n        }\r\n        // save stores in instances to access them devtools\r\n        if ((process.env.NODE_ENV !== 'production') &&\r\n            IS_CLIENT &&\r\n            currentInstance &&\r\n            currentInstance.proxy &&\r\n            // avoid adding stores that are just built for hot module replacement\r\n            !hot) {\r\n            const vm = currentInstance.proxy;\r\n            const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\r\n            cache[id] = store;\r\n        }\r\n        // StoreGeneric cannot be casted towards Store\r\n        return store;\r\n    }\r\n    useStore.$id = id;\r\n    return useStore;\r\n}\n\nlet mapStoreSuffix = 'Store';\r\n/**\r\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\r\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\r\n * interface if you need are using TypeScript.\r\n *\r\n * @param suffix - new suffix\r\n */\r\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\r\n) {\r\n    mapStoreSuffix = suffix;\r\n}\r\n/**\r\n * Allows using stores without the composition API (`setup()`) by generating an\r\n * object to be spread in the `computed` field of a component. It accepts a list\r\n * of store definitions.\r\n *\r\n * @example\r\n * ```js\r\n * export default {\r\n *   computed: {\r\n *     // other computed properties\r\n *     ...mapStores(useUserStore, useCartStore)\r\n *   },\r\n *\r\n *   created() {\r\n *     this.userStore // store with id \"user\"\r\n *     this.cartStore // store with id \"cart\"\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @param stores - list of stores to map to an object\r\n */\r\nfunction mapStores(...stores) {\r\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\r\n        console.warn(`[ðŸ]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\r\n            `Replace\\n` +\r\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\r\n            `with\\n` +\r\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\r\n            `This will fail in production if not fixed.`);\r\n        stores = stores[0];\r\n    }\r\n    return stores.reduce((reduced, useStore) => {\r\n        // @ts-expect-error: $id is added by defineStore\r\n        reduced[useStore.$id + mapStoreSuffix] = function () {\r\n            return useStore(this.$pinia);\r\n        };\r\n        return reduced;\r\n    }, {});\r\n}\r\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapState(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            reduced[key] = function () {\r\n                return useStore(this.$pinia)[key];\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function () {\r\n                const store = useStore(this.$pinia);\r\n                const storeKey = keysOrMapper[key];\r\n                // for some reason TS is unable to infer the type of storeKey to be a\r\n                // function\r\n                return typeof storeKey === 'function'\r\n                    ? storeKey.call(this, store)\r\n                    : store[storeKey];\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\r\n/**\r\n * Alias for `mapState()`. You should use `mapState()` instead.\r\n * @deprecated use `mapState()` instead.\r\n */\r\nconst mapGetters = mapState;\r\n/**\r\n * Allows directly using actions from your store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `methods` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapActions(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function (...args) {\r\n                return useStore(this.$pinia)[key](...args);\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function (...args) {\r\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\r\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapWritableState(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            // @ts-ignore\r\n            reduced[key] = {\r\n                get() {\r\n                    return useStore(this.$pinia)[key];\r\n                },\r\n                set(value) {\r\n                    // it's easier to type it here as any\r\n                    return (useStore(this.$pinia)[key] = value);\r\n                },\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-ignore\r\n            reduced[key] = {\r\n                get() {\r\n                    return useStore(this.$pinia)[keysOrMapper[key]];\r\n                },\r\n                set(value) {\r\n                    // it's easier to type it here as any\r\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\r\n                },\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\n\n/**\r\n * Creates an object of references with all the state, getters, and plugin-added\r\n * state properties of the store. Similar to `toRefs()` but specifically\r\n * designed for Pinia stores so methods and non reactive properties are\r\n * completely ignored.\r\n *\r\n * @param store - store to extract the refs from\r\n */\r\nfunction storeToRefs(store) {\r\n    // See https://github.com/vuejs/pinia/issues/852\r\n    // It's easier to just use toRefs() even if it includes more stuff\r\n    if (isVue2) {\r\n        // @ts-expect-error: toRefs include methods and others\r\n        return toRefs(store);\r\n    }\r\n    else {\r\n        store = toRaw(store);\r\n        const refs = {};\r\n        for (const key in store) {\r\n            const value = store[key];\r\n            if (isRef(value) || isReactive(value)) {\r\n                // @ts-expect-error: the key is state or getter\r\n                refs[key] =\r\n                    // ---\r\n                    toRef(store, key);\r\n            }\r\n        }\r\n        return refs;\r\n    }\r\n}\n\n/**\r\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\r\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\r\n * https://pinia.vuejs.org/ssr/nuxt.html.\r\n *\r\n * @example\r\n * ```js\r\n * import Vue from 'vue'\r\n * import { PiniaVuePlugin, createPinia } from 'pinia'\r\n *\r\n * Vue.use(PiniaVuePlugin)\r\n * const pinia = createPinia()\r\n *\r\n * new Vue({\r\n *   el: '#app',\r\n *   // ...\r\n *   pinia,\r\n * })\r\n * ```\r\n *\r\n * @param _Vue - `Vue` imported from 'vue'.\r\n */\r\nconst PiniaVuePlugin = function (_Vue) {\r\n    // Equivalent of\r\n    // app.config.globalProperties.$pinia = pinia\r\n    _Vue.mixin({\r\n        beforeCreate() {\r\n            const options = this.$options;\r\n            if (options.pinia) {\r\n                const pinia = options.pinia;\r\n                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L30\r\n                /* istanbul ignore else */\r\n                if (!this._provided) {\r\n                    const provideCache = {};\r\n                    Object.defineProperty(this, '_provided', {\r\n                        get: () => provideCache,\r\n                        set: (v) => Object.assign(provideCache, v),\r\n                    });\r\n                }\r\n                this._provided[piniaSymbol] = pinia;\r\n                // propagate the pinia instance in an SSR friendly way\r\n                // avoid adding it to nuxt twice\r\n                /* istanbul ignore else */\r\n                if (!this.$pinia) {\r\n                    this.$pinia = pinia;\r\n                }\r\n                pinia._a = this;\r\n                if (IS_CLIENT) {\r\n                    // this allows calling useStore() outside of a component setup after\r\n                    // installing pinia's plugin\r\n                    setActivePinia(pinia);\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        registerPiniaDevtools(pinia._a, pinia);\r\n                    }\r\n                }\r\n            }\r\n            else if (!this.$pinia && options.parent && options.parent.$pinia) {\r\n                this.$pinia = options.parent.$pinia;\r\n            }\r\n        },\r\n        destroyed() {\r\n            delete this._pStores;\r\n        },\r\n    });\r\n};\n\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };\n"]},"metadata":{},"sourceType":"module"}